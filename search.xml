<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[全栈开发实战：用Vue2+Koa2开发完整的前后端项目]]></title>
    <url>%2F2020%2F08%2F14%2F%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%9A%E7%94%A8Vue2%2BKoa2%E5%BC%80%E5%8F%91%E5%AE%8C%E6%95%B4%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[本文从一名新手的角度（默认对Vue有了解，对Koa或者Express有了解）出发，从0开始构建一个数据通过Koa提供API的形式获取，页面通过Vue渲染的完整的前端项目。可以了解到Vue构建单页面的一些知识以及前端路由的使用、Koa如何提供API接口，如何进行访问过滤（路由）、验证（JSON-WEB-TOKEN）以及Sequelize操作MySQL数据库的一些知识和技巧，希望能够作为一篇入门全栈开发的文章吧。 更新：文末给出的github仓库已经更新Koa2版本。请使用Node.js v7.6.0及以上版本体验~ 写在前面我曾经写过一篇文章，是用express和mongodb入门Nodejs的前后端开发，这篇文章里简单的做了一个小demo，能够让你读写mongodb数据库，并且从数据库里将数据读取出来显示到页面上。算是一个简单的读写小demo吧，也算是服务端渲染的一次初尝试。并且我还写过用nodejs写简单小爬虫的文章，用爬虫来获取数据写入数据库。通过以上的的方法我用express写了一个小网站，记录并显示北邮人论坛每天的十大的内容。挺好玩的对吧，可以把想要做的事用代码来实现。 后来我接触到了Koa，并开始了学习，从express迁移到Koa其实曲线还算是比较平滑的。不过用Koa的方式也还是采用服务端渲染页面的方式。而且我发现目前网络上少有写过用Koa构建的前后端分离的应用、网站文章，我最近做的一个项目里需要用到的方式就是用Vue构建页面，数据的获取全部走后端API的形式，也就是所谓的前后端分离吧。正好在这过程中走了不少的坑，包括数据库的使用上也算是个新手，所以写篇文章记录一下，用同样的思路和方法构建一个简单的Todolist，欢迎讨论，轻拍~ 项目结构123456789101112131415161718192021222324252627282930313233343536├── LICENSE├── README.md├── .env // 环境变量配置文件├── app.js // Koa入口文件├── build // vue-cli 生成，用于webpack监听、构建│ ├── build.js│ ├── check-versions.js│ ├── dev-client.js│ ├── dev-server.js│ ├── utils.js│ ├── webpack.base.conf.js│ ├── webpack.dev.conf.js│ └── webpack.prod.conf.js├── config // vue-cli 生成&amp;自己加的一些配置文件│ ├── default.conf│ ├── dev.env.js│ ├── index.js│ └── prod.env.js├── dist // Vue build 后的文件夹│ ├── index.html // 入口文件│ └── static // 静态资源├── index.html // vue-cli生成，用于容纳Vue组件的主html文件。单页应用就只有一个html├── package.json // npm的依赖、项目信息文件├── server // Koa后端，用于提供Api│ ├── config // 配置文件夹│ ├── controllers // controller-控制器│ ├── models // model-模型│ ├── routes // route-路由│ └── schema // schema-数据库表结构├── src // vue-cli 生成&amp;自己添加的utils工具类│ ├── App.vue // 主文件│ ├── assets // 相关静态资源存放│ ├── components // 单文件组件│ ├── main.js // 引入Vue等资源、挂载Vue的入口js│ └── utils // 工具文件夹-封装的可复用的方法、功能└── yarn.lock // 用yarn自动生成的lock文件 看起来好像很复杂的样子，其实很大一部分文件夹的结构是vue-cli这个工具帮我们生成的。而我们需要额外添加的主要是Koa的入口文件以及一个server文件夹用于Koa提供API。这样的话，在获取数据的方面就可以走Koa所提供的API，而Vue只需关心怎么把这些数据渲染到页面上就好了。 项目用到的一些关键依赖以下依赖的版本都是本文所写的时候的版本，或者更旧一些 Vue.js(v2.1.8) Vue-Router(v2.1.1) Axios(v0.15.3) Element(v1.1.2) Koa.js(v1.2.4) // 没采用Koa2 Koa-Router@5.4\Koa-jwt\Koa-static等一系列Koa中间件 Mysql(v2.12.0) // nodejs的mysql驱动，并不是mysql本身版本（项目采用mysql5.6） Sequelize(v3.28.0) // 操作数据库的ORM Yarn(v0.18.1) // 比起npm更快一些 剩下依赖可以参考本文最后给出的项目demo仓库。 项目启动Nodejs与npm的安装不再叙述（希望大家装上的node版本大于等于6.x，不然还需要加上–harmony标志才可以开启es6），默认读者已经掌握npm安装依赖的方法。首先全局安装npm i vue-cli -g，当然本项目基本上是采用yarn，所以也可以yarn global add vue-cli。 Tips: 可以给yarn换上淘宝源，速度更快: yarn config set registry &quot;https://registry.npm.taobao.org&quot; 然后我们初始化一个Vue2的webpack的模板： 1vue init webpack demo Tips: 上面的demo可以填写你自己的项目名称 然后进行一些基本配置选择之后，你就可以得到一个基本的vue-cli生成的项目结构。 接着我们进入vue-cli生成的目录，安装Vue的项目依赖并安装Koa的项目依赖：yarn &amp;&amp; yarn add koa koa-router@5.4 koa-logger koa-json koa-bodyparser，（注意是安装koa-router的5.4版，因为7.X版本是支持Koa2的）然后进行一些基本目录建立： 在vue-cli生成的demo目录下，建立server文件夹以及子文件夹： 123456├── server // Koa后端，用于提供Api ├── config // 配置文件夹 ├── controllers // controller-控制器 ├── models // model-模型 ├── routes // route-路由 └── schema // schema-数据库表结构 然后在demo文件夹下我们创建一个app.js的文件，作为Koa的启动文件。 写入如下基本的内容就可以启动Koa啦： 1234567891011121314151617181920const app = require('koa')() , koa = require('koa-router')() , json = require('koa-json') , logger = require('koa-logger'); // 引入各种依赖app.use(require('koa-bodyparser')());app.use(json());app.use(logger());app.use(function* (next)&#123; let start = new Date; yield next; let ms = new Date - start; console.log('%s %s - %s', this.method, this.url, ms); // 显示执行的时间&#125;);app.on('error', function(err, ctx)&#123; console.log('server error', err);&#125;);app.listen(8889,() =&gt; &#123; console.log('Koa is listening in 8889');&#125;);module.exports = app; 然后在控制台输入node app.js，能看到输出Koa is listening in 8889，则说明我们的Koa已经启动成功了，并在8889端口监听。 前端页面构建这个DEMO是做一个Todo-List，我们首先来做一个登录页面。 Tips: 为了方便构建页面和美观，本文采用的Vue2的前端UI框架是element-ui。安装：yarn add element-ui 模板引擎我习惯用pug，CSS预处理我习惯用stylus，当然每个人自己的习惯和喜好是不一样的，所以大家根据自己平时的喜好来就行了。 为了方便大家查看代码，就不用pug了，学习成本相对高一些。不过CSS用stylus写起来简便，看起来也不会难懂，是我自己的习惯，所以还需要安装一下yarn add stylus stylus-loader。 Tips: 安装stylus-loader是为了让webpack能够渲染stylus 然后要把element-ui引入项目中。打开src/main.js，将文件改写如下： 12345678910import Vue from 'vue'import App from './App'import ElementUI from 'element-ui' // 引入element-uiimport 'element-ui/lib/theme-default/index.css'Vue.use(ElementUI) // Vue全局使用new Vue(&#123; el: '#app', template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 然后我们在项目根目录下输入npm run dev，启动开发模式，这个模式有webpack的热加载，也就是你写完代码，浏览器立即就能响应变化。 为了实现响应式页面，我们要在项目目录下的index.html的head标签内加入以下meta： 登录界面进入src/components目录，新建一个Login.vue的文件。然后我们来写第一个页面： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;el-row class="content"&gt; &lt;el-col :xs="24" :sm="&#123;span: 6,offset: 9&#125;"&gt; &lt;span class="title"&gt; 欢迎登录 &lt;/span&gt; &lt;el-row&gt; &lt;el-input v-model="account" placeholder="账号" type="text"&gt; &lt;/el-input&gt; &lt;el-input v-model="password" placeholder="密码" type="password"&gt; &lt;/el-input&gt; &lt;el-button type="primary"&gt;登录&lt;/el-button&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; account: '', password: '' &#125;; &#125;&#125;;&lt;/script&gt;&lt;style lang="stylus" scoped&gt; .el-row.content padding 16px .title font-size 28px .el-input margin 12px 0 .el-button width 100% margin-top 12px &lt;/style&gt; 在这里就有一些值得注意的地方。首先是template标签内的直接子元素最多只能挂载一个。也就是你不能这么写： 1234&lt;template&gt; &lt;el-row&gt;&lt;/el-row&gt; &lt;el-row&gt;&lt;/el-row&gt;&lt;/template&gt; 否则会报错：template syntax error Component template should contain exactly one root element，template下只能有一个根元素。不过为了写多个元素，你可以这样： 123456&lt;template&gt; &lt;div&gt; &lt;el-row&gt;&lt;/el-row&gt; &lt;el-row&gt;&lt;/el-row&gt; &lt;/div&gt;&lt;/template&gt; 同时注意到，在Login.vue的style标签内有个scoped属性，这个属性能够使这些样式只在这个组件内生效（因为Webpack在渲染的时候会将这个组件内的元素自动打上一串形如data-v-62a7f97e这样的属性，对于这些样式也会变成形如.title[data-v-62a7f97e]{ font-size: 28px;}的样子，保证了不会和其他组件的样式冲突。 页面写完之后，如果不把组件注册到Vue之下那么页面是不会显示的。因此这个时候需要把APP.vue这个文件改写一下： 1234567891011121314151617181920212223242526**&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;Login&gt;&lt;/Login&gt; &lt;!--使用Login组件--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Login from './components/Login' // 引入Login组件export default &#123; name: 'app', components: &#123; Login // 注册组件 &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt;** 也就是把Login这个组件注册到Vue下，同时你再看浏览器，已经不再是vue-cli默认生成的Hello欢迎界面了。 Login 接着我们写一下登录成功后的界面。 TodoList页面还是在src/components目录下，写一个叫做TodoList.vue的文件。 接着我们开始写一个TodoList： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;template&gt; &lt;el-row class="content"&gt; &lt;el-col :xs="&#123;span:20,offset:2&#125;" :sm="&#123;span:8,offset:8&#125;"&gt; &lt;span&gt; 欢迎：&#123;&#123;name&#125;&#125;！你的待办事项是： &lt;/span&gt; &lt;el-input placeholder="请输入待办事项" v-model="todos" @keyup.enter.native="addTodos"&gt;&lt;/el-input&gt; &lt;el-tabs v-model="activeName"&gt; &lt;el-tab-pane label="待办事项" name="first"&gt; &lt;el-col :xs="24"&gt; &lt;template v-if="!Done"&gt; &lt;!--v-if和v-for不能同时在一个元素内使用，因为Vue总会先执行v-for--&gt; &lt;template v-for="(item, index) in list"&gt; &lt;div class="todo-list" v-if="item.status == false"&gt; &lt;span class="item"&gt; &#123;&#123; index + 1 &#125;&#125;. &#123;&#123; item.content &#125;&#125; &lt;/span&gt; &lt;span class="pull-right"&gt; &lt;el-button size="small" type="primary" @click="finished(index)"&gt;完成&lt;/el-button&gt; &lt;el-button size="small" :plain="true" type="danger" @click="remove(index)"&gt;删除&lt;/el-button&gt; &lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/template&gt; &lt;div v-else-if="Done"&gt; 暂无待办事项 &lt;/div&gt; &lt;/el-col&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane label="已完成事项" name="second"&gt; &lt;template v-if="count &gt; 0"&gt; &lt;template v-for="(item, index) in list"&gt; &lt;div class="todo-list" v-if="item.status == true"&gt; &lt;span class="item finished"&gt; &#123;&#123; index + 1 &#125;&#125;. &#123;&#123; item.content &#125;&#125; &lt;/span&gt; &lt;span class="pull-right"&gt; &lt;el-button size="small" type="primary" @click="restore(index)"&gt;还原&lt;/el-button&gt; &lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/template&gt; &lt;div v-else&gt; 暂无已完成事项 &lt;/div&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;/el-col&gt; &lt;/el-row&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; name: 'Molunerfinn', todos: '', activeName: 'first', list:[], count: 0 &#125;; &#125;, computed: &#123; // 计算属性用于计算是否已经完成了所有任务 Done()&#123; let count = 0; let length = this.list.length; for(let i in this.list)&#123; this.list[i].status == true ? count += 1 : ''; &#125; this.count = count; if(count == length || length == 0)&#123; return true &#125;else&#123; return false &#125; &#125; &#125;, methods: &#123; addTodos() &#123; if(this.todos == '') return let obj = &#123; status: false, content: this.todos &#125; this.list.push(obj); this.todos = ''; &#125;, finished(index) &#123; this.$set(this.list[index],'status',true) // 通过set的方法让数组的变动能够让Vue检测到 this.$message(&#123; type: 'success', message: '任务完成' &#125;) &#125;, remove(index) &#123; this.list.splice(index,1); this.$message(&#123; type: 'info', message: '任务删除' &#125;) &#125;, restore(index) &#123; this.$set(this.list[index],'status',false) this.$message(&#123; type: 'info', message: '任务还原' &#125;) &#125; &#125;&#125;;&lt;/script&gt;&lt;style lang="stylus" scoped&gt; .el-input margin 20px auto .todo-list width 100% margin-top 8px padding-bottom 8px border-bottom 1px solid #eee overflow hidden text-align left .item font-size 20px &amp;.finished text-decoration line-through color #ddd .pull-right float right&lt;/style&gt; 页面构建其实没有什么特别好说的，但是因为我自己有踩点坑，所以还是专门讲一下： v-if和v-for放在一个元素内同时使用，因为Vue总会先执行v-for，所以导致v-if不会被执行。替代地，你可以使用一个额外的template元素用来放置v-if或者v-for从而达到同样的目的。这是相关的issue。 计算属性对于直接的数据比如a: 2 -&gt; a: 3这样的数据变动可以直接检测到。但是如果是本例中的list的某一项的status这个属性变化了，如果我们直接使用list[index].status = true这样的写法的话，Vue将无法检测到数据变动。替代地，可以使用set方法（全局是Vue.set()，实例中是this.$set()），通过set方法可以让数据的变动变得可以被检测到。从而让计算属性能够捕捉到变化。可以参考官方文档对于响应式原理的描述。 Todolist 写完TodoList之后，我们需要将它和vue-router配合起来，从而使这个单页应用能够进行页面跳转。 页面路由由于不采用服务端渲染，所以页面路由走的是前端路由。安装一下vue-router：yarn add vue-router。 安装好后，我们挂载一下路由。打开main.js文件改写如下： 1234567891011121314151617181920212223242526272829303132// src/main.jsimport Vue from 'vue'import App from './App'import ElementUI from 'element-ui'import 'element-ui/lib/theme-default/index.css'import VueRouter from 'vue-router'Vue.use(ElementUI);Vue.use(VueRouter);import Login from `./components/Login`import TodoList from `./components/TodoList`const router = new VueRouter(&#123; mode: 'history', // 开启HTML5的history模式，可以让地址栏的url长得跟正常页面跳转的url一样。（不过还需要后端配合，讲Koa的时候会说） base: __dirname, routes: [ &#123; path: '/', // 默认首页打开是登录页 component: Login &#125;, &#123; path: '/todolist', component: TodoList &#125;, &#123; path: '*', redirect: '/' // 输入其他不存在的地址自动跳回首页 &#125; ]&#125;)const app = new Vue(&#123; router: router, // 启用router render: h =&gt; h(App) &#125;).$mount('#app') //挂载到id为app的元素上 这样就把路由挂载好了，但是你打开页面发现好像还是没有什么变化。这是因为我们没有把路由视图放到页面上。现在我们改写一下APP.vue： 12345678910111213141516171819202122&lt;!-- APP.vue --&gt;&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 原本的Login换成了router-view 这就是路由视图渲染的目标元素--&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app' // 不需要再引入`Login`\`TodoList`组件了，因为在路由里已经注册了&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 然后再看一下你的页面，这个时候你如果在地址栏后加上/todolist那么就会跳转到TodoList页面啦。 不过我们如何通过点击登录按钮跳转到TodoList呢？改写一下Login.vue，就可以跳转了。 只需要给登录的button加一个方法即可： 123456789101112131415161718192021222324252627&lt;!-- Login.vue --&gt;······&lt;!-- 给input增加键盘事件，当输入完密码回车也执行loginToDo方法 --&gt;&lt;el-input v-model="password" placeholder="密码" type="password" @keyup.enter.native="loginToDo"&gt;&lt;/el-input&gt;&lt;!-- 增加一个click方法 loginToDo --&gt;&lt;el-button type="primary" @click="loginToDo"&gt;登录&lt;/el-button&gt;······&lt;script&gt;export default &#123; data () &#123; return &#123; account: '', password: '' &#125;; &#125;, methods: &#123; loginToDo() &#123; this.$router.push('/todolist') // 编程式路由，通过push方法，改变路由。 &#125; &#125;&#125;;&lt;/script&gt; 然后你就可以通过点击登录按钮进行页面跳转了。并且你可以发现，页面地址从localhost:8080变成了localhost:8080/todolist，长得跟正常的url跳转一样。（但是实际上我们是单页应用，只是在应用内进行页面跳转而已，没有向后端额外请求） login2todolist 至此，我们已经完成了一个纯前端的单页应用，能够进行页面跳转，能够做简单的ToDoList的添加和删除和还原。当然这个东西只能算是个能看不能用的东西——因为登录系统有名无实、ToDoList只要页面刷新一下就没了。 于是我们可以先把前端放一放。开启我们的后端之旅。 后端环境搭建MySQL之所以没有用Node界大家普遍喜爱的Mongodb主要是因为之前我用过它，而没有用过MySQL，本着学习的态度，我决定用用MySQL。还有就是Express + Mongodb的教程其实很早之前就已经满大街都是了。所以如果你觉得Mongodb更合你的胃口，看完本文你完全可以用Mongodb构建一个类似的应用。 去MySQL的官网下载安装对应平台MySQL的Community Server。 通常来说安装的步骤都是比较简单的。对于MySQL的基本安装、开启步骤可以参考这篇文章，这篇是windows的。当然其他平台的安装也是很方便的，都有相应的包管理工具可以获取。值得注意的就是，安装完MySQL之后你需要设定一下root账户的密码。保证安全性。如果你漏了设定，或者你不知道怎么设定，可以参考这篇文章 因为我对MySQL的SQL语句不是很熟悉，所以我需要一个可视化的工具来操作MySQL。Windows上我用的是HediSQL，macOS上我用的是Sequel Pro。它们都是免费的。 然后我们可以用这些可视化工具连上MySQL的server（默认端口是3306）之后，创建一个新的数据库，叫做todolist。（当然你也可以用SQL语句:CREATE DATABASE todolist，之后不再赘述）。 接着我们可以来开始创建数据表了。 我们需要创建两张表，一张是用户表，一张是待办事项表。用户表用于登录、验证，待办事项表用于展示我们的待办事项。 创建一张user表，其中password我们稍后会进行bcrypt加密（取128位）。 | 字段 | 类型 | 说明 | | ——— | ———– | ———- | | id | int（自增） | 用户的id | | user_name | CHAR(50) | 用户的名字 | | password | CHAR(128) | 用户的密码 | 创建一张list表，所需的字段是id、user_id、content、status即可。 | 字段 | 类型 | 说明 | | ——- | ———– | ———- | | id | int（自增） | list的id | | user_id | int(11) | 用户的id | | content | CHAR(255) | list的内容 | | status | tinyint(1) | list的状态 | 直接跟数据库打交道的部分基本就是这样了。 Sequelize跟数据库打交道的时候我们都需要一个好的操作数据库的工具，能够让我们用比较简单的方法来对数据库进行增删改查。对于Mongodb来说大家熟悉的是Mongoose以及我用过一个相对更简单点的Monk。对于MySQL，我选用的是Sequelize，它支持多种关系型数据库（Sqlite、MySQL、Postgres等），它的操作基本都能返回一个Promise对象，这样在Koa里面我们能够很方便地进行”同步”操作。 更多关于Sequelize的用法，可以参考官方文档，以及这两篇文章——Sequelize中文API文档、Sequelize和MySQL对照 在用Sequelize连接数据库之前我们需要把数据库的表结构用sequelize-auto导出来。 更多关于sequelize-auto的使用可以参考官方介绍或者这篇文章 由此我们需要分别安装这几个依赖：yarn global add sequelize-auto &amp;&amp; yarn add sequelize mysql。 注：上面用yarn安装的mysql是nodejs环境下的mysql驱动。 进入server的目录，执行如下语句sequelize-auto -o &quot;./schema&quot; -d todolist -h 127.0.0.1 -u root -p 3306 -x XXXXX -e mysql，（其中 -o 参数后面的是输出的文件夹目录， -d 参数后面的是数据库名， -h 参数后面是数据库地址， -u 参数后面是数据库用户名， -p 参数后面是端口号， -x 参数后面是数据库密码，这个要根据自己的数据库密码来！ -e 参数后面指定数据库为mysql） 然后就会在schema文件夹下自动生成两个文件： 123456789101112131415161718192021// user.jsmodule.exports = function(sequelize, DataTypes) &#123; return sequelize.define('user', &#123; id: &#123; type: DataTypes.INTEGER(11), // 字段类型 allowNull: false, // 是否允许为NULL primaryKey: true, // 主键 autoIncrement: true // 是否自增 &#125;, user_name: &#123; type: DataTypes.CHAR(50), // 最大长度为50的字符串 allowNull: false &#125;, password: &#123; type: DataTypes.CHAR(32), allowNull: false &#125; &#125;, &#123; tableName: 'user' // 表名 &#125;);&#125;; 12345678910111213141516171819202122232425// list.jsmodule.exports = function(sequelize, DataTypes) &#123; return sequelize.define('list', &#123; id: &#123; type: DataTypes.INTEGER(11), allowNull: false, primaryKey: true, autoIncrement: true &#125;, user_id: &#123; type: DataTypes.INTEGER(11), allowNull: false &#125;, content: &#123; type: DataTypes.CHAR(255), allowNull: false &#125;, status: &#123; type: DataTypes.INTEGER(1), allowNull: false &#125; &#125;, &#123; tableName: 'list' &#125;);&#125;; 自动化工具省去了很多我们手动定义表结构的时间。同时注意到生成的数据库表结构文件都自动帮我们module.exports出来了，所以很方便我们之后的引入。 在server目录下的config目录下我们新建一个db.js，用于初始化Sequelize和数据库的连接。 1234567891011// db.jsconst Sequelize = require('sequelize'); // 引入sequelize// 使用url连接的形式进行连接，注意将root: 后面的XXXX改成自己数据库的密码const Todolist = new Sequelize('mysql://root:XXXX@localhost/todolist',&#123; define: &#123; timestamps: false // 取消Sequelzie自动给数据表加入时间戳（createdAt以及updatedAt） &#125;&#125;) module.exports = &#123; Todolist // 将Todolist暴露出接口方便Model调用&#125; 接着我们去models文件夹里将数据库和表结构文件连接起来。在这个文件夹下新建一个user.js的文件。我们先来写一个查询用户id的东西。 为此我们可以先在数据库里随意加一条数据： test 通常我们要查询一个用户id为1的数据，会很自然的想到类似如下的写法： 12const userInfo = User.findOne(&#123; where: &#123; id: 1&#125; &#125;); // 查询console.log(userInfo); // 输出结果 但是上面的写法实际上是行不通的。因为JS的特性让它的IO操作是异步的。而上面的写法，userInfo将是返回的一个Promise对象，而不是最终的userInfo。如果又想用同步的写法获取异步IO操作得到的数据的话，通常情况下是不能直接得到的。但是在Koa里，由于有co的存在，让这一切变得十分简单。改写如下： 12345678910111213141516// models/user.jsconst db = require('../config/db.js'), userModel = '../schema/user.js'; // 引入user的表结构const TodolistDb = db.Todolist; // 引入数据库const User = TodolistDb.import(userModel); // 用sequelize的import方法引入表结构，实例化了User。const getUserById = function* (id)&#123; // 注意是function* 而不是function 对于需要yield操作的函数都需要这种generator函数。 const userInfo = yield User.findOne(&#123; // 用yield控制异步操作，将返回的Promise对象里的数据返回出来。也就实现了“同步”的写法获取异步IO操作的数据 where: &#123; id: id &#125; &#125;); return userInfo // 返回数据&#125;module.exports = &#123; getUserById // 导出getUserById的方法，将会在controller里调用&#125; 接着我们在controllers写一个user的controller，来执行这个方法，并返回结果。 12345678910// controllers/user.js const user = require('../models/user.js');const getUserInfo = function* ()&#123; const id = this.params.id; // 获取url里传过来的参数里的id const result = yield user.getUserById(id); // 通过yield “同步”地返回查询结果 this.body = result // 将请求的结果放到response的body里返回&#125;module.exports = &#123; getUserInfo // 把获取用户信息的方法暴露出去 &#125; 写完这个还不能直接请求，因为我们还没有定义路由，请求经过Koa找不到这个路径是没有反应的。 在routes文件夹下写一个auth.js的文件。（其实user表是用于登录的，所以走auth） 12345// routes/auth.jsconst auth = require('../controllers/user.js'); const router = require('koa-router')();router.get('/user/:id', auth.getUserInfo); // 定义url的参数是id,用user的auth方法引入routermodule.exports = router; // 把router规则暴露出去 至此我们已经接近完成我们的第一个API了，还缺最后一步，将这个路由规则“挂载”到Koa上去。 回到根目录的app.js，改写如下： 1234567891011121314151617181920212223const app = require('koa')() , koa = require('koa-router')() , json = require('koa-json') , logger = require('koa-logger') , auth = require('./server/routes/auth.js'); // 引入authapp.use(require('koa-bodyparser')());app.use(json());app.use(logger());app.use(function* (next)&#123; let start = new Date; yield next; let ms = new Date - start; console.log('%s %s - %s', this.method, this.url, ms);&#125;);app.on('error', function(err, ctx)&#123; console.log('server error', err);&#125;);koa.use('/auth', auth.routes()); // 挂载到koa-router上，同时会让所有的auth的请求路径前面加上'/auth'的请求路径。app.use(koa.routes()); // 将路由规则挂载到Koa上。app.listen(8889,() =&gt; &#123; console.log('Koa is listening in 8889');&#125;);module.exports = app; 打开你的控制台，输入node app.js，一切运行正常没有报错的话，大功告成，我们的第一个API已经构建完成！ 如何测试呢？ API Test接口在跟跟前端对接之前，我们应该先进行一遍测试，防止出现问题。在测试接口的工具上，我推荐Postman，这个工具能够很好的模拟发送的各种请求，方便的查看响应结果，用来进行测试是最好不过了。 Postman 测试成功，我发送了正确的url请求，返回的结果也是我想看到的。我们看到返回的结果实际上是个JSON，这对于我们前后端来说都是十分方便处理的数据格式。 但是如果我们代码出了问题，返回error了我们该怎么测试呢？如果说控制台能够反馈一定的信息，但是绝对不充分，并且我们很可能不知道哪步出错了导致最终结果出问题。 所以我推荐用VSCode这个工具来帮我们调试nodejs后端的代码。它能够添加断点，能够很方便地查看请求的信息。并且配合上nodemon这类的工具，调试简直不要更舒服。 关于VSCode的nodejs调试，可以参考官方的这篇文章 我自己是用Sublime写代码，用VSCode调试，哈哈。 登录系统的实现刚才实现的不过是一个简单的用户信息查询的接口，但是我们要实现的是一个登录系统，所以还需要做一些工作。 JSON-WEB-TOKEN基于cookie或者session的登录验证已经屡见不鲜，前段时间JSON-WEB-TOKEN出来后很是风光了一把。引入了它之后，能够实现真正无状态的请求，而不是基于session和cookie的存储式的有状态验证。 关于JSON-WEB-TOKEN的描述可以参考这篇文章比较简单，我还推荐一篇文章，将如何使用JSON-WEB-TOKEN写得很清楚。 另外可以在JSON-WEB-TOKEN的官网上感受一下。 Tips：JSON-WEB-TOKEN分三部分，头部信息+主体信息+密钥信息，其中主体传递的信息（是我们存放我们需要的信息的部分）是用BASE64编码的，所以很容易被解码，一定不能存放明文密码这种关键信息！替代地可以存放一些不是特别关键的信息，比如用户名这样能够做区分的信息。 简单来说，运用了JSON-WEB-TOKEN的登录系统应该是这样的： 用户在登录页输入账号密码，将账号密码（密码进行md5加密）发送请求给后端 后端验证一下用户的账号和密码的信息，如果符合，就下发一个TOKEN返回给客户端。如果不符合就不发送TOKEN回去，返回验证错误信息。 如果登录成功，客户端将TOKEN用某种方式存下来（SessionStorage、LocalStorage）,之后要请求其他资源的时候，在请求头（Header）里带上这个TOKEN进行请求。 后端收到请求信息，先验证一下TOKEN是否有效，有效则下发请求的资源，无效则返回验证错误。 通过这个TOKEN的方式，客户端和服务端之间的访问，是无状态的：也就是服务端不知道你这个用户到底还在不在线，只要你发送的请求头里的TOKEN是正确的我就给你返回你想要的资源。这样能够不占用服务端宝贵的空间资源，而且如果涉及到服务器集群，如果服务器进行维护或者迁移或者需要CDN节点的分配的话，无状态的设计显然维护成本更低。 话不多说，我们来把JSON-WEB-TOKEN用到我们的项目中。 yarn add koa-jwt，安装Koa的JSON-WEB-TOKEN库。 我们需要在models里的user.js加一个方法，通过用户名查找用户： 12345678910111213141516// models/user.js// ......// 前面的省略了// 新增一个方法，通过用户名查找const getUserByName = function* (name)&#123; const userInfo = yield User.findOne(&#123; where: &#123; user_name: name &#125; &#125;) return userInfo&#125;module.exports = &#123; getUserById, // 导出getUserById的方法，将会在controller里调用 getUserByName&#125; 然后我们写一下controllers里的user.js： 12345678910111213141516171819202122232425262728293031323334353637383940// controllers/user.jsconst user = require('../models/user.js');const jwt = require('koa-jwt'); // 引入koa-jwtconst getUserInfo = function* ()&#123; const id = this.params.id; // 获取url里传过来的参数里的id const result = yield user.getUserById(id); // 通过yield “同步”地返回查询结果 this.body = result // 将请求的结果放到response的body里返回&#125;const postUserAuth = function* ()&#123; const data = this.request.body; // post过来的数据存在request.body里 const userInfo = yield user.getUserByName(data.name); if(userInfo != null)&#123; // 如果查无此用户会返回null if(userInfo.password != data.password)&#123; this.body = &#123; success: false, // success标志位是方便前端判断返回是正确与否 info: '密码错误！' &#125; &#125;else&#123; // 如果密码正确 const userToken = &#123; name: userInfo.user_name, id: userInfo.id &#125; const secret = 'vue-koa-demo'; // 指定密钥，这是之后用来判断token合法性的标志 const token = jwt.sign(userToken,secret); // 签发token this.body = &#123; success: true, token: token, // 返回token &#125; &#125; &#125;else&#123; this.body = &#123; success: false, info: '用户不存在！' // 如果用户不存在返回用户不存在 &#125; &#125;&#125;module.exports = &#123; getUserInfo, postUserAuth&#125; 再把routes里的路由规则更新一下： 123456// routes/auth.jsconst auth = require('../controllers/user.js'); const router = require('koa-router')();router.get('/user/:id', auth.getUserInfo); // 定义url的参数是id,用user的auth方法引入routerrouter.post('/user', auth.postUserAuth);module.exports = router; // 把router规则暴露出去 由此我们写完了用户认证的部分。接下去我们要改写一下前端登录的方法。 引入Axios之前在学Vue的时候一直用的是vue-resource，不过后来Vue2出来之后，Vue官方不再默认推荐它为官方的ajax网络请求库了。替代地推荐了一些其他的库，比如就有我们今天要用的axios。我之前也没有用过它，不过看完它的star和简要介绍Promise based HTTP client for the browser and node.js，能够同时支持node和浏览器端的ajax请求工具（还是基于Promised的！），我想就有必要用一用啦。 yarn add axios，安装axios。然后我们在src/main.js里面引入axios： 12345// scr/main.js// ...import Axios from 'axios'Vue.prototype.$http = Axios // 类似于vue-resource的调用方法，之后可以在实例里直接用this.$http.get()等// ... 123456789101112131415161718192021222324252627// Login.vue// 省略前面的部分 methods: &#123; loginToDo() &#123; let obj = &#123; name: this.account, password: this.password &#125; this.$http.post('/auth/user', obj) // 将信息发送给后端 .then((res) =&gt; &#123; // axios返回的数据都在res.data里 if(res.data.success)&#123; // 如果成功 sessionStorage.setItem('demo-token',res.data.token); // 用sessionStorage把token存下来 this.$message(&#123; // 登录成功，显示提示语 type: 'success', message: '登录成功！' &#125;); this.$router.push('/todolist') // 进入todolist页面，登录成功 &#125;else&#123; this.$message.error(res.data.info); // 登录失败，显示提示语 sessionStorage.setItem('demo-token',null); // 将token清空 &#125; &#125;, (err) =&gt; &#123; this.$message.error('请求错误！') sessionStorage.setItem('demo-token',null); // 将token清空 &#125;) &#125; &#125; 密码bcrypt加密最早的时候我是在前端用了md5加密，但是后来经过提醒这种方式并不安全。md5加密的容易被破解。所以就采用了bcrypt的加密方式。全部走后端加密。也许你会问这样明文给后端发送密码安全吗？没问题，只要用上HTTPS，这将不是问题。 yarn add bcryptjs安装bcryptjs。 1234567891011121314151617181920212223242526272829303132333435363738394041// controllers/user.jsconst user = require('../models/user.js');const jwt = require('koa-jwt'); // 引入koa-jwtconst bcrypt = require('bcryptjs');const getUserInfo = function* ()&#123; const id = this.params.id; // 获取url里传过来的参数里的id const result = yield user.getUserById(id); // 通过yield “同步”地返回查询结果 this.body = result // 将请求的结果放到response的body里返回&#125;const postUserAuth = function* ()&#123; const data = this.request.body; // post过来的数据存在request.body里 const userInfo = yield user.getUserByName(data.name); if(userInfo != null)&#123; // 如果查无此用户会返回null if(!bcrypt.compareSync(data.password, userInfo.password))&#123; // 验证密码是否正确 this.body = &#123; success: false, // success标志位是方便前端判断返回是正确与否 info: '密码错误！' &#125; &#125;else&#123; // 如果密码正确 const userToken = &#123; name: userInfo.user_name, id: userInfo.id &#125; const secret = 'vue-koa-demo'; // 指定密钥，这是之后用来判断token合法性的标志 const token = jwt.sign(userToken,secret); // 签发token this.body = &#123; success: true, token: token, // 返回token &#125; &#125; &#125;else&#123; this.body = &#123; success: false, info: '用户不存在！' // 如果用户不存在返回用户不存在 &#125; &#125;&#125;module.exports = &#123; getUserInfo, postUserAuth&#125; 因为我们数据库里还是存着明文的123作为密码，现在要先将它bcrypt化，加密后变为：$2a$10$x3f0Y2SNAmyAfqhKVAV.7uE7RHs3FDGuSYw.LlZhOFoyK7cjfZ.Q6，将其替换掉数据库里的123。不做这步我们将无法登录。 还没有大功告成，因为我们的界面跑在8080端口，但是Koa提供的API跑在8889端口，所以如果直接通过/auth/user这个url去post是请求不到的。就算写成localhost:8889/auth/user也会因为跨域问题导致请求失败。 这个时候有两种最方便的解决办法： 如果是跨域，服务端只要在请求头上加上CORS，客户端即可跨域发送请求。 变成同域，即可解决跨域请求问题。 第一种也很方便，采用kcors即可解决。 不过为了之后部署方便，我们采用第二种，变成同域请求。 打开根目录下的config/index.js，找到dev下的proxyTable，利用这个proxyTable我们能够将外部的请求通过webpack转发给本地，也就能够将跨域请求变成同域请求了。 将proxyTable改写如下: 12345678910proxyTable: &#123; '/auth':&#123; target: 'http://localhost:8889', changeOrigin: true &#125;, '/api':&#123; target: 'http://localhost:8889', changeOrigin: true &#125;&#125; 上面的意思是，我们在组件里请求的地址如果是/api/xxxx实际上请求的是http://localhost:8889/api/xxxx，但是由于webpack帮我们代理了localhost的8889端口的服务，所以我们可以把实际是跨域的请求当做是同域下的接口来调用。 此时重新启动一下webpack：先ctrl+c退出当前进程，然后npm run dev。 一切都万事了之后，我们可以看到如下激动人心的画面： login2todolist 跳转拦截虽然我们现在能够成功登录系统了，但是还是存在一个问题：我在地址栏手动将地址改为localhost:8080/todolist我还是能够成功跳转到登录后的界面啊。于是这就需要一个跳转拦截，当没有登录的时候，不管地址栏输入什么地址，最终都重新定向回登录页。 这个时候，从后端给我们传回来的token就派上大用处。有token就说明我们的身份是经过验证的，否则就是非法的。 vue-router提供了页面跳转的钩子，我们可以在router跳转前进行验证，如果token存在就跳转，如果不存在就返回登录页。 参考路由的导航钩子 打开src/main.js，修改如下： 12345678910111213141516171819// src/main.js// ...const router = new VueRouter(&#123;....&#125;) // 省略router.beforeEach((to,from,next) =&gt;&#123; const token = sessionStorage.getItem('demo-token'); if(to.path == '/')&#123; // 如果是跳转到登录页的 if(token != 'null' &amp;&amp; token != null)&#123; next('/todolist') // 如果有token就转向todolist不返回登录页 &#125; next(); // 否则跳转回登录页 &#125;else&#123; if(token != 'null' &amp;&amp; token != null)&#123; next() // 如果有token就正常转向 &#125;else&#123; next('/') // 否则跳转回登录页 &#125; &#125;&#125;)const app = new Vue(&#123;...&#125;) // 省略 注意：一定要确保要调用 next() 方法，否则钩子就不会被 resolved。如果纯粹调用next(path)这样的方法最终还是会回到.beforeEach()这个钩子里面来，如果没有写对条件就有可能出现死循环，栈溢出的情况。 然后我们就可以看到如下效果： login2todolist Tips：这种只判断token存不存在就通过的验证是很不安全的，此例只是做了一个演示，实际上还应该进行更深一层的判断，比如从token解包出来的信息里包含我们想要的信息才可以作为有效token，才可以登录。等等。本文只是做一个简要介绍。 解析token注意到我们在签发token的时候，写过这样几句话： 123456789// server/controllers/user.js// ...const userToken = &#123; name: userInfo.user_name, id: userInfo.id&#125;const secret = 'vue-koa-demo'; // 指定密钥，这是之后用来判断token合法性的标志const token = jwt.sign(userToken,secret); // 签发token// ... 我们将用户名和id打包进JWT的主体部分，同时我们解密的密钥是vue-koa-demo。所以我们可以通过这个信息，来进行登录后的用户名显示，以及用来区别这个用户是谁，这个用户有哪些Todolist。 接下来在Todolist页面进行token解析，从而让用户名显示为登录用户名。 注意： 前端直接暴露secret-key的做法其实并不安全。正确的做法应该是把token跟用户名和其他不是很重要的信息一起传过来，token只用于验证，而其他信息作为返回值正常返回。这样就不会暴露secret-key了。当然本文只是为了方便说明，给出的一个不恰当的获取用户信息的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142// src/components/TodoList.vue// ...import jwt from 'jsonwebtoken' // 我们安装koa-jwt的时候会自动下载这个依赖export default &#123; created()&#123; // 组件创建时调用 const userInfo = this.getUserInfo(); // 新增一个获取用户信息的方法 if(userInfo != null)&#123; this.id = userInfo.id; this.name = userInfo.name; &#125;else&#123; this.id = ''; this.name = '' &#125; &#125;, data () &#123; return &#123; name: '', // 用户名改为空 todos: '', activeName: 'first', list:[], count: 0, id: '' // 新增用户id属性，用于区别用户 &#125;; &#125;, computed: &#123;...&#125;, //省略 methods: &#123; addTodos() &#123;...&#125;, // 省略 finished(index) &#123;...&#125;, remove(index) &#123;...&#125;, restore(index) &#123;...&#125;, getUserInfo()&#123; // 获取用户信息 const token = sessionStorage.getItem('demo-token'); if(token != null &amp;&amp; token != 'null')&#123; let decode = jwt.decode(token); // 解析token return decode // decode解析出来实际上就是&#123;name: XXX,id: XXX&#125; &#125;else &#123; return null &#125; &#125; &#125;&#125;;// ... 于是你就可以看到： todolist 用户名已经不是我们之前默认的Molunerfinn而是登录名molunerfinn了。 Todolist 增删改查的实现这个部分就是前后端协作了。我们要实现之前在纯前端部分实现的内容。我以最基本的两个方法来举例子：获取Todolist以及增加Todolist，剩下其实思路大同小异，我就提供代码和注释了，我相信也很容易懂。 Token的发送之前说了，用JSON-WEB-TOKEN之后，这个系统的验证就完全依靠token了。如果token正确就下发资源，如果资源不正确，就返回错误信息。 因为我们用了koa-jwt，所以只需要在每条请求头上加上Authorization属性，值是Bearer {token值}，然后让Koa在接收请求之前验证一下token即可。但是如果每发一条请求就要手动写一句这个，太累了。于是我们可以做到全局Header设定。 打开src/main.js，在路由跳转的钩子里加上这句： 1234567891011121314151617// scr/main.jsonrouter.beforeEach((to,from,next) =&gt;&#123; const token = sessionStorage.getItem('demo-token'); if(to.path == '/')&#123; if(token != 'null' &amp;&amp; token != null)&#123; next('/todolist') &#125; next(); &#125;else&#123; if(token != 'null' &amp;&amp; token != null)&#123; Vue.prototype.$http.defaults.headers.common['Authorization'] = 'Bearer ' + token; // 全局设定header的token验证，注意Bearer后有个空格 next() &#125;else&#123; next('/') &#125; &#125;&#125;) 这样就完成了token的客户端发送设定。 Koa端对Token的验证接着我们实现两个简单的api，这两个api请求的路径就不是/auth/xxx而是/api/xxx了。我们还需要实现，访问/api/*路径的请求都需要经过koa-jwt的验证，而/auth/*的请求不需要。 首先去models目录下新建一个todolist.js的文件： 1234567891011121314151617181920212223242526// server/models/todolist.jsconst db = require('../config/db.js'), todoModel = '../schema/list.js'; // 引入todolist的表结构const TodolistDb = db.Todolist; // 引入数据库const Todolist = TodolistDb.import(todoModel); const getTodolistById = function* (id)&#123; // 获取某个用户的全部todolist const todolist = yield Todolist.findAll(&#123; // 查找全部的todolist where: &#123; user_id: id &#125;, attributes: ['id','content','status'] // 只需返回这三个字段的结果即可 &#125;); return todolist // 返回数据&#125;const createTodolist = function* (data)&#123; // 给某个用户创建一条todolist yield Todolist.create(&#123; user_id: data.id, // 用户的id，用来确定给哪个用户创建 content: data.content, status: data.status &#125;) return true&#125;module.exports = &#123; getTodolistById, createTodolist&#125; 接着去controllers目录下新建一个todolist.js的文件： 123456789101112131415161718// server/controllers/todolistconst todolist = require('../models/todolist.js');const getTodolist = function* ()&#123; // 获取某个用户的所有todolist const id = this.params.id; // 获取url里传过来的参数里的id const result = yield todolist.getTodolistById(id); // 通过yield “同步”地返回查询结果 this.body = result // 将请求的结果放到response的body里返回&#125;const createTodolist = function* ()&#123; // 给某个用户创建一条todolist const data = this.request.body; // post请求，数据是在request.body里的 const result = yield todolist.createTodolist(data); this.body = &#123; success: true &#125;&#125;module.exports = &#123; getTodolist, createTodolist&#125; 然后去routes文件夹里新建一个api.js文件： 12345// server/routes/api.jsconst todolist = require('../controllers/todolist.js');const router = require('koa-router')();todolist(router); // 引入koa-routermodule.exports = router; // 导出router规则 最后，去根目录下的app.js，给koa加上新的路由规则： 1234567891011121314151617181920212223242526272829303132333435363738// app.jsconst app = require('koa')() , koa = require('koa-router')() , json = require('koa-json') , logger = require('koa-logger') , auth = require('./server/routes/auth.js') , api = require('./server/routes/api.js') , jwt = require('koa-jwt');// ..... 省略app.use(function* (next)&#123; let start = new Date; yield next; let ms = new Date - start; console.log('%s %s - %s', this.method, this.url, ms);&#125;);app.use(function *(next)&#123; // 如果JWT验证失败，返回验证失败信息 try &#123; yield next; &#125; catch (err) &#123; if (401 == err.status) &#123; this.status = 401; this.body = &#123; success: false, token: null, info: 'Protected resource, use Authorization header to get access' &#125;; &#125; else &#123; throw err; &#125; &#125;&#125;);app.on('error', function(err, ctx)&#123; console.log('server error', err);&#125;);koa.use('/auth', auth.routes()); // 挂载到koa-router上，同时会让所有的auth的请求路径前面加上'/auth'的请求路径。koa.use("/api",jwt(&#123;secret: 'vue-koa-demo'&#125;),api.routes()) // 所有走/api/打头的请求都需要经过jwt中间件的验证。secret密钥必须跟我们当初签发的secret一致app.use(koa.routes()); // 将路由规则挂载到Koa上。// ...省略 至此，后端的两个api已经构建完成。 初始化配置相对复杂一些，涉及到model、controllers、routes和app.js，可能会让人望而却步。实际上第一次构建完成之后，后续要添加api，基本上只需要在model和controllers写好方法，定好接口即可，十分方便。 前端对接接口后端接口已经开放，接下来要把前端和后端进行对接。主要有两个对接接口： 获取某个用户的所有todolist 创建某个用户的一条todolist 接下来就是改写Todolist.vue里的方法了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// todolist.js// ... 省略created()&#123; const userInfo = this.getUserInfo(); if(userInfo != null)&#123; this.id = userInfo.id; this.name = userInfo.name; &#125;else&#123; this.id = ''; this.name = '' &#125; this.getTodolist(); // 新增：在组件创建时获取todolist&#125;,// ... 省略methods: &#123; addTodos() &#123; if(this.todos == '') return let obj = &#123; status: false, content: this.todos, id: this.id &#125; this.$http.post('/api/todolist', obj) // 新增创建请求 .then((res) =&gt; &#123; if(res.status == 200)&#123; // 当返回的状态为200成功时 this.$message(&#123; type: 'success', message: '创建成功！' &#125;) this.getTodolist(); // 获得最新的todolist &#125;else&#123; this.$message.error('创建失败！') // 当返回不是200说明处理出问题 &#125; &#125;, (err) =&gt; &#123; this.$message.error('创建失败！') // 当没有返回值说明服务端错误或者请求没发送出去 console.log(err) &#125;) this.todos = ''; // 将当前todos清空 &#125;, // ... 省略一些方法 getTodolist()&#123; this.$http.get('/api/todolist/' + this.id) // 向后端发送获取todolist的请求 .then((res) =&gt; &#123; if(res.status == 200)&#123; this.list = res.data // 将获取的信息塞入实例里的list &#125;else&#123; this.$message.error('获取列表失败！') &#125; &#125;, (err) =&gt; &#123; this.$message.error('获取列表失败！') console.log(err) &#125;) &#125;&#125; 至此，前后端的部分已经完整构建。让我们来看看效果： todolist 做到这一步的时候其实我们的应用已经基本完成了。最后的收尾工作，让我们来收一下。 原本的前端版本还有完成、删除、还原三种状态，其中完成和还原只是状态的切换（更新），所以可以算是一个api，然后就是删除是单独一个api。于是我们就能算是完成了增、删、改、查了。接下去的部分就提供代码就行，其实思路跟之前的是一样的，只不过操作的函数不一样罢了。 Todolist的改、删12345678910111213141516171819202122232425262728293031// server/models/todolist.js// ...省略const removeTodolist = function* (id,user_id)&#123; yield Todolist.destroy(&#123; where: &#123; id, user_id &#125; &#125;) return true&#125;const updateTodolist = function* (id,user_id,status)&#123; yield Todolist.update( &#123; status &#125;, &#123; where: &#123; id, user_id &#125; &#125; ) return true&#125;module.exports = &#123; getTodolistById, createTodolist, removeTodolist, updateTodolist&#125; 1234567891011121314151617181920212223242526// server/controllers/todolist.js// ... 省略const removeTodolist = function* ()&#123; const id = this.params.id; const user_id = this.params.userId; const result = yield todolist.removeTodolist(id,user_id); this.body = &#123; success: true &#125;&#125;const updateTodolist = function* ()&#123; const id = this.params.id; const user_id = this.params.userId; let status = this.params.status; status == '0' ? status = true : status = false;// 状态反转（更新） const result = yield todolist.updateTodolist(id,user_id,status); this.body = &#123; success: true &#125;&#125;module.exports = (router) =&gt; &#123; getTodolist, createTodolist, removeTodolist, updateTodolist&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!-- src/components/TodoList.vue --&gt;....&lt;!-- 把完成和还原的方法替换成了update --&gt;&lt;el-button size="small" type="primary" @click="update(index)"&gt;完成&lt;/el-button&gt;....&lt;el-button size="small" type="primary" @click="update(index)"&gt;还原&lt;/el-button&gt;....&lt;script&gt;// ....省略 methods:&#123; // ... 省略 update(index) &#123; this.$http.put('/api/todolist/'+ this.id + '/' + this.list[index].id + '/' + this.list[index].status) .then((res) =&gt; &#123; if(res.status == 200)&#123; this.$message(&#123; type: 'success', message: '任务状态更新成功！' &#125;) this.getTodolist(); &#125;else&#123; this.$message.error('任务状态更新失败！') &#125; &#125;, (err) =&gt; &#123; this.$message.error('任务状态更新失败！') console.log(err) &#125;) &#125;, remove(index) &#123; this.$http.delete('/api/todolist/'+ this.id + '/' + this.list[index].id) .then((res) =&gt; &#123; if(res.status == 200)&#123; this.$message(&#123; type: 'success', message: '任务删除成功！' &#125;) this.getTodolist(); &#125;else&#123; this.$message.error('任务删除失败！') &#125; &#125;, (err) =&gt; &#123; this.$message.error('任务删除失败！') console.log(err) &#125;) &#125;, &#125;// ... 省略&lt;/script&gt;.... 让我们来看看最后99%成品的效果吧： Todolist 项目部署很多教程到类似于我上面的部分就结束了。但是实际上我们做一个项目最想要的就是部署给大家用不是么？ 在部署这块有些坑，需要让大家也一起知道一下。这个项目是个全栈项目（虽然是个很简单的。。。），所以就涉及到前后端通信的问题，也就会涉及到是同域请求还是跨域请求。 我们也说过，要解决这个问题有两种方便的解决办法，第一种，服务端加上cors，客户端就可以随意的跨域请求。但是这样会有个问题，因为我们是以同域的形式开发，请求的地址也是写的相对地址：/api/*、auth/*这样的路径，访问的路径的自然是同域。如果要在服务端加上cors，我们还需要将我们的所有请求地址改成localhost:8889/api/*，localhost:8889/auth/*，这样的话，如果服务端的端口号一变，我们还需要重新修改前端所有的请求地址。这样很不方便也很不科学。 因此，要将请求变为同域才是最好的解决办法——不管服务端端口号怎么变，只要是同域都可以请求到。 于是要把Vue和Koa结合起来变成一个完整的项目（之前实际上都是在开发模式下，webpack帮我们进行请求的代理转发，所以看起来像是同域请求，而Vue和Koa并没有完全结合起来），就得在生产模式下，将Vue的静态文件交给Koa“托管”，所有访问前端的请求全部走Koa端，包括静态文件资源的请求，也走Koa端，把Koa作为一个Vue项目的静态资源服务器，这样就可以让Vue里的请求走的都是同域了。（相当于，之前开发模式是webpack开启了一个服务器托管了Vue的资源和请求，现在生产模式下改成Koa托管Vue的资源和请求） 要在开发和生产模式改变不同的托管服务器，其实也很简单，只需要在生产模式下，用Koa的静态资源服务中间件托管构建好的Vue文件即可。 Webpack打包部署之前我们要用Webpack将我们的前端项目打包输出一下。但是如果直接用npm run build，你会发现打包出来的文件太大了： 12345678910111213Asset Size Chunks Chunk Names static/css/app.d9034fc06fd57ce00d6e75ed49f0dafe.css 120 kB 2, 0 [emitted] app static/fonts/element-icons.a61be9c.eot 13.5 kB [emitted] static/img/element-icons.09162bc.svg 17.4 kB [emitted] static/js/manifest.8ea250834bdc80e4d73b.js 832 bytes 0 [emitted] manifest static/js/vendor.75bbe7ecea37b0d4c62d.js 623 kB 1, 0 [emitted] vendor static/js/app.e2d125562bfc4c57f9cb.js 16.5 kB 2, 0 [emitted] app static/fonts/element-icons.b02bdc1.ttf 13.2 kB [emitted] static/js/manifest.8ea250834bdc80e4d73b.js.map 8.86 kB 0 [emitted] manifest static/js/vendor.75bbe7ecea37b0d4c62d.js.map 3.94 MB 1, 0 [emitted] vendor static/js/app.e2d125562bfc4c57f9cb.js.map 64.8 kB 2, 0 [emitted] appstatic/css/app.d9034fc06fd57ce00d6e75ed49f0dafe.css.map 151 kB 2, 0 [emitted] app index.html 563 bytes [emitted] 竟然有3.94MB的map文件。这肯定是不能接受的。于是要修改一下webpack的输出的设置，取消输出map文件。 找到根目录下的config/index.js：把productionSourceMap: true这句话改成productionSourceMap: false。然后再执行一遍npm run build。 123456789Asset Size Chunks Chunk Names static/fonts/element-icons.a61be9c.eot 13.5 kB [emitted] static/fonts/element-icons.b02bdc1.ttf 13.2 kB [emitted] static/img/element-icons.09162bc.svg 17.4 kB [emitted] static/js/manifest.3ba218c80028a707a728.js 774 bytes 0 [emitted] manifest static/js/vendor.75bbe7ecea37b0d4c62d.js 623 kB 1, 0 [emitted] vendor static/js/app.b6acaca2531fc0baa447.js 16.5 kB 2, 0 [emitted] appstatic/css/app.d9034fc06fd57ce00d6e75ed49f0dafe.css 120 kB 2, 0 [emitted] app index.html 563 bytes [emitted] 把sourceMap去掉了之后，体积就小下来了。虽然600+kb的大小还是有点大，不过放到服务端，gzip之后只剩150+kb的体积勉强还是可以接受。当然，对于webpack输出的优化，不是本文讨论的范围，有很多更好的文章讲述了这个东西，故本文不再详细展开。 打包好后就是相当于输出了一堆静态文件，当然这堆静态文件需要放在服务端才可以访问。我们要将这堆静态资源用Koa托管。 Koa serve静态资源yarn add koa-static 打开app.js，引入两个新依赖，其中path是nodejs原生自带。 1234567891011// app.js// .... const path =require('path') , serve = require('koa-static');// ....// 静态文件serve在koa-router的其他规则之上 app.use(serve(path.resolve('dist'))); // 将webpack打包好的项目目录作为Koa静态文件服务的目录// 下面这些是之前就有的。。。为了方便找位置故标示出来koa.use('/auth', auth.routes());koa.use("/api",jwt(&#123;secret: 'vue-koa-demo'&#125;),api.routes()) // ... 然后重新运行一遍node app.js，看到输出Koa is listening in 8889后，你可以打开浏览器localhost:8889就可以看到如下情景： vue-koa 至此已经基本上接近尾声，不过还存在一个问题：如果我们登录进去之后，在todolist页面一刷新，就会出现： 404 为什么会出现这种情况？简单来说是因为我们使用了前端路由，用了HTML5 的History模式，如果没有做其他任何配置的话，刷新页面，那么浏览器将会去服务端访问这个页面地址，因为服务端并没有配置这个地址的路由，所以自然就返回404 Not Found了。 详细可以参考vue-router的这篇文档 该怎么解决？其实也很简单，多加一个中间件：koa-history-api-fallback即可. yarn add koa-history-api-fallback 1234567//... 省略const historyApiFallback = require('koa-history-api-fallback'); // 引入依赖app.use(require('koa-bodyparser')());app.use(json());app.use(logger());app.use(historyApiFallback()); // 在这个地方加入。一定要加在静态文件的serve之前，否则会失效。// ... 这个时候，你再重新启动一下koa，登录之后再刷新页面，就不会再出现404 Not Found了。 API Test本来写到上面基本本文已经算是结束了。但是由于我在开发的过程中遇到了一些问题，所以还需要做一些微调。 我们知道koa的use方法是有顺序只差的。 123const app = require('koa');app.use(A);app.use(B); 123const app = require('koa');app.use(B);app.use(A); 这二者是有区别的，谁先被use，谁的规则就放到前面先执行。 因此如果我们将静态文件的serve以及historyApiFallback放在了api的请求之前，那么用postman测试api的时候总会先返回完整的页面： postman 因此正确的做法，应该是将它们放到我们写的api的规则之后： 1234567// app.js// ...koa.use('/auth', auth.routes()); // 挂载到koa-router上，同时会让所有的auth的请求路径前面加上'/auth'的请求路径。koa.use("/api",jwt(&#123;secret: 'vue-koa-demo'&#125;),api.routes()) // 所有走/api/打头的请求都需要经过jwt验证。app.use(koa.routes()); // 将路由规则挂载到Koa上。app.use(historyApiFallback()); // 将这两个中间件挂载在api的路由之后app.use(serve(path.resolve('dist'))); // 将webpack打包好的项目目录作为Koa静态文件服务的目录 这样就能正常返回数据了。 Nginx配置真正部署到服务器的时候，我们肯定不会让大家输入域名:8889这样的方式让大家访问。所以需要用Nginx监听80端口，把访问我们指定域名的请求引导转发给Koa服务端。 大致的nginx.conf如下： 12345678910111213141516http &#123; # .... upstream koa.server&#123; server 127.0.0.1:8889; &#125; server &#123; listen 80; server_name xxx.xxx.com; location / &#123; proxy_pass http://koa.server; proxy_redirect off; &#125; #.... &#125; #....&#125; 如果有精力还可以配置一下Nginx的Gzip，能让请求的JS\CSS\HTML等静态文件更小，响应速度更快些。 写在最后至此，我们已经完成了一个从前端到后端，从本地到服务器的完整项目。虽然它真的是个很简单的小东西，被大家也已经用其他的方式写烂了（比如用localStorage做存储）。但是它作为一个完整的前后端的DEMO，我觉得让大家入门也相对更容易一些，能够体会到全栈开发也不是想象中的“那么难”（入门的难度还是可以接受的嘛）。有了Nodejs之后我们能够做的事真的好多！ 当然，由于篇幅有限，本文能够讲述东西毕竟不够多，而且讲的东西也不可能面面俱到，很多东西都是点到即止，让大家能够自己发挥。其实还想讲讲Event Bus的简单使用，还有分页的基本实现等等，东西太多了，一时间大家消化不了。 实际上我在做前段时间的项目的时候，也是完全不知道怎么把Vue和Koa结合起来开发。我甚至不知道怎么用Koa来提供API，我只会用Koa来做服务端渲染，比如那些JADE\EJS等模板引擎渲染的页面。所以之前那个项目做完让我自己学到良多东西，故而也分享给大家。 实际上本文的Koa的api提供的形式也尽量和RESTful靠拢了，因此你也可以学会如何通过Koa提供RESTful形式的API了。 最后放上本文项目的Github地址，如果这个项目对你有帮助，希望大家可以fork，给我提建议，如果再有时间，可以点个Star那就更好啦~ 另外，本文的版本是用Koa1写成的。仓库已经更新Koa2。从Koa1-&gt;Koa2并没有什么难度，其实很关键的两点是： 用async await替代yield generation 用koa2的中间件替代koa1的中间件，原因同上一条 互相学习，如果能从这个项目里学到东西我就很开心啦~]]></content>
      <categories>
        <category>全栈开发</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在2020，什么工具能取代Evernote/印象笔记？]]></title>
    <url>%2F2020%2F08%2F13%2F2020%E7%9A%84%E7%AC%94%E8%AE%B0%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。 在信息越来越丰富的今天，有一批敢于尝鲜的笔记爱好者们已经不再痴迷于以简洁语法为代表的 Markdown，而是转向自由化、定制化的模块化笔记。 他们利用各式各样的模块打造高度可视化的笔记，并公开发表，传播影响力。在看到这些精美的作品后，又有一批用户发现模块化提供了更好的编辑和整理体验，以及可视化带来的效用。 但市面上的享誉盛名的模块化笔记琳琅满目，导致这些后来者不知道选择哪款作为主力笔记，这真是一个幸福的烦恼。所以，我将完整对比现在最流行的、知名度最高的 5 款模块化笔记，帮助你挑选适合自己的笔记 app。 一眼看完强大功能现在最流行的新兴笔记 app 分别是《Notion》《Roam Research》《Wolai》《Craft》 和《Obsidian》。尽管最后一款并不是模块化笔记，但不妨碍它们共同给笔记 app 注入了新的活力。 先对比下最为重要的功能。 大家可以根据这张表格初步了解重要的功能，接下来将介绍下它们各自最强大的功能。 为什么你要选其中一款这 5 款笔记 app 各有千秋，看完之后相信一定有一款能击中你的心。 Notion：最强大的 Database《Notion》是将模块化笔记发扬光大的先驱者。 提到它，先想到的一定是各式各样的模块。比如下图我用了重点、标题、文本、无序列表、内嵌视频 5 种模块，并拖拽将其并列，从而实现强化版的康奈尔笔记。 既可以边看视频边记笔记，也可以通过左边的关键词回顾右边的内容。 但我更想说的是被称为 2.0 版本的灵魂「Database」模块。它的灵感来自于《Airtable》，本质上是一个关系型数据库。有了它，《Notion》才和其他普通笔记软件真正拉开了差距。 由于每一行数据都是一个单独页面，所以它能够帮助我们更好地组织同类型笔记，并且在该页面下记录相关内容，最后根据我们的需要筛选出符合某一场景的内容。比如我就用它来组织所有的稿件。 这只是其中一个用法，配合它其他的功能，你甚至可以自建一个免费的《Things 3》作为你新的 GTD 软件。更多用法可以参照官方模板，或网络搜索。 Roam Research：让你的笔记编织成网不知道你的英语老师教你背单词的方法是不是以一个单词为中心，然后向外扩散写下尽可能多能想到的单词，并且保证它们之间有联系。 比如下图就是我以「Apple」为中心展开的单词联想，写多了之后，你会发现它可能会变成这样。 这其实才是我们大脑记忆的真实样子，知识不是独立的，而是各自有联系。 《Notion》的数据库帮助我们更好的组织和管理笔记，而《Roam Research》引进的双向链接和关系图则帮我们更好地建立起了笔记之间的联系。 此前的笔记链接只能单向跳转，即你过去了回不来，但双向链接可以让你在笔记之间来去自如。这特别像我们在回顾手写笔记时的样子，摊开笔记，一会看下这个知识点，一会看下那个知识点，思考两者有什么联系。双向链接现在就直接把该页面相关的其他页面在最底下给你展示完整，而你只需要负责思考。 对于这种网状结构的笔记，跳来跳去自然是很麻烦的，好在 Roam Research 还提供了侧边栏，只需按住 Shift 再打开即可。侧边栏用于快速查看参考页面，并且可以同时显示多条记录，这对于查看同一页面的多个引用是十分友好的。 此外，《Roam Research》的块引用、页面别名、逻辑词筛选内容等强大功能增强了我们做笔记的能力，更多内容可阅读《秒杀传统型笔记！支持 Markdown 和双向链接的 Roam Research 为什么这么强？》。 Obsidian：大屏幕的福音《Obsidian》则是另外一款同样专注于双向链接和页面关系图的笔记 app。 但它的特别之处是本地编辑和本地存储，把数据安全交到你手里。 最直接的好处就是响应速度极快，不会出现因为网络问题而无法使用的情况。但因本质上是 Markdown 笔记，所以《Obsidian》无法进行段落内容的互相引用，只能是标题互相引用。 另外，它还支持各种插件，你可以根据自己的需要选用插件。所以你还可以做一些其他笔记软件无法做到的事情，比如录音、随机复习笔记、快速新建卡片盒笔记等。 最后，是它另一个特别之处，多窗格展示。 卡片盒笔记的核心是每一个笔记只有一个观点，这样才能帮助你更好地掌握。所以，多窗格非常有效，你能在一个屏幕上看到相关的笔记内容，也就更能有效地理解和记忆。不过前提是你的屏幕足够大。 Wolai：集百家之所长《Wolai》是唯一一款中文化的笔记 app。你可以将其视作《Notion》和《Roam Research》的结合体，它既拥有前者的编辑体验，也具备后者的双向链接和页面关系图。 虽然模块丰富度暂时不及《Notion》，但对中文环境进行了很多功能和设计上的优化，更符合中文用户的使用习惯，比如输入「》」也能实现「&gt;」的效果。除此以外，还对页面关系图进行了优化，内容如下： 可以检索某一页面。 对子页面和引用页面做了设计样式区分。 增加了关系图的展示样式。 增加了 3D 关系图，但目前实用性较差。 这些优化能够更好地帮助我们厘清页面之间的联系，在回顾阶段会有良好的引导作用。 另外一个特别吸引人的小功能是，你可以自定义域名，比如我就自定义了一个 wol.ai/blog。等后期公开分享功能上线后，把自己笔记分享给别人会变得无比简单和迅速。先吃螃蟹的人总会有好处。 目前，《Wolai》仍处于内测阶段，更新速度极快。如果想要抢先体验，可输入 AppSo 专属无限邀请码【9Z4K2K3】。 Craft：丝滑般的体验与上述 4 款软件不同，《Craft》没有那么强大的功能，可以视作《Notion》刚发布时的版本，但胜在苹果生态下的原生体验。同时，它也是唯一一款支持手写功能的笔记 app。 之所以提它，是因为你可能并不需要强大的功能，而只是需要一款在苹果生态下能够快速记录，实时同步，且外观精美的笔记 app。 它同样也是模块化笔记，公开链接的访问速度很快，因此非常适合用来写文章。 你适合哪款笔记 app看完了那么多笔记 app，你是不是觉得每款都很强大，不知道该选择哪款呢？下面是我的个人建议： 如果你是跟学生一样主要用于学习记录的话，考虑到功能和访问速度，建议优选《Obsidian》《Wolai》，其次是《Notion》《Roam Research》。当然，如果你需要丰富的模块的话，《Notion》必然是最优选择。 如果你是开发者，有很多代码需要记录，建议使用《Wolai》《Notion》。 如果你是一个热爱折腾，有很强动手能力的用户，可以尝试《Roam Research》《Obsidian》。它们支持自定义 CSS，你也就可以根据自己的需求，调整页面展示样式。 如果你特别在意数据安全，那就选择《Obsidian》和《Craft》。其余 3 款均为云端笔记软件，且《Notion》《Roam Research》的服务器在境外，但谁又能保证本地存储一定比云端存储安全呢？ 如果你想写出优美的文章，《Notion》《Craft》《Wolai》均可。 其他人可以根据自己的需求和 app 收费情况进行选择。 以上的功能总结和使用推荐是基于当前软件版本。正如苹果和 Android 越来越像，这些软件的功能肯定也会越来越像，毕竟用户都是「你有的，我也要有」，那么选择笔记的落脚点肯定就是细节上的体验了。 哪款能让你坚持记录、长期使用，那么它才是真正能帮助你成长的那款笔记 app。不妨多多尝试，然后选择适合自己的。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>wolai</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[印象笔记+hexo搭建自己的博客]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0%2Bhexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[之前在逛V2EX的时候以外发现一个好玩的东西,就是使用印象笔记Evernote来写文章让后生成响应的html同步到hexo上面。由于自己在生活中使用印象笔记的频率也比较高，而且收藏文章的时候也比较方便。不用自己又特意转成md格式的,这样子省时省力所以决定把自己的博客搭建给换成这个框架来搭建。 搭建过程： 一、安装everblog1. Install everblog: $ npm i everblog -g $ vim ~/.everblogrc token: xxx, noteStoreUrl: xxx, notebook: myblog 2. Clone theme, like everblog-theme-spa: $ git clone https://github.com/everblogjs/everblog-theme-spa myblog $ cd myblog &amp;&amp; npm i 3. Open evernote: create a new notebook named myblog create a new note named \_config.yml, add some configs, like: title, description create some notes 4. Start everblog: $ DEBUG=* everblog start 二、Adapter适配器以上是原框架作者的搭建过程，但是本人自己在实践的过程中出现了很多问题，所以并没有完全按照他的版本来做。我用的是网上搜索出来的另一位作者的方法，他同时也把自己的代码提交到了everblog中，大家可以看commit记录，使用zhougy0717的版本来搭建，这个是我搭建过程中所有遇到的问题他都很热心的帮助解答了，对话记录,希望能帮助到你. 按照以上操作只能算是完成了一半，你还有在你当前的hexo博客目录安装一个everblog-adaptor-hexo（也就是你hexo init的那个目录） $ cd your_hexo_blog_dir $ npm i everblog-adaptor-hexo –save $ vim index.js, add module.exports = require(&#39;everblog-adaptor-hexo&#39;) Open evernote, create \_config.yml(see below) and some notes title: NSWBMW’s blog subtitle: lalala description: my blog author: nswbmw $ everblog build $ hexo server $ open http://localhost:4000/ 注意由于本人在使用以上框架的时候出现了很多问题，我用的Adapter是其他版本的everblog-adaptor-hexo-html cd your_hexo_blog_dir npm i everblog-adaptor-hexo-html –save vim index.js, add: module.exports = require(‘everblog-adaptor-hexo-html’) DEBUG=* everblog build (see everblog) 由于上面安装的第一个步骤也就是npm i everblog -g中安装了很多文件夹，但是有一个evernote这个文件夹的版本不是我所需要的我需要的版本是`evernote@1.25.82,所以你只需要使用命令安装sudo npm install evernote@1.25.82就可以了，当然最好你要先删除掉usr/local/lib/node_modules/evernote先在安装不然我担心它还是会使用默认的evernote2.0`版本。 最后打开你的印象笔记，新建笔记本组新建一个名字.everblogrc文件中notebook同名的笔记本组，我的就叫myblog 我的.everblogrc配置如下 token:d9fab5c755171aedf0d9fab5c755171aedf0d9fab5c755171aedf0d9fab5c755171aedf0 noteStoreUrl: ‘https://app.yinxiang.com/shard/sxx/notestore‘ notebook: myblog serviceHost: app.yinxiang.com sandbox: false 三、申请Token上面的Token是从你自己的个人开发者上面获取到的 国际版Evernote：https://www.evernote.com/api/DeveloperToken.action 国内版印象笔记：https://app.yinxiang.com/api/DeveloperToken.action 由于Evernote因为安全问题已经自动把Token的功能给砍掉了，但是你可以让客服单独为你账号开通 以上所有步骤都完成之后，在你印象笔记里面新建的笔记本组里新建一个名为_config.yml的文件然后把你hexo目录下面的config.yml全部复制进去（后面我印象笔记没有这个东西好像也能同步也不知道是为什么，可能是我换了其他Adapter的原因吧） 只要在首页不是缩略展示文章的都是在印象笔记中完成的，因为.md文件会自动截断文章，但是Evernote的文章内容不会]]></content>
  </entry>
  <entry>
    <title><![CDATA[直接让网页版应用做你的桌面 App]]></title>
    <url>%2F2019%2F06%2F27%2F%E7%9B%B4%E6%8E%A5%E8%AE%A9%E7%BD%91%E9%A1%B5%E7%89%88%E5%BA%94%E7%94%A8%E5%81%9A%E4%BD%A0%E7%9A%84%E6%A1%8C%E9%9D%A2-App%2F</url>
    <content type="text"><![CDATA[💻 随着互联网前端的迅捷发展，越来越多产品网页端的使用体验愈加完善。用 Web 技术搭建的 网页应用 不仅有着现代化的 UI，甚至体验比原生桌面客户端都要好上不少。 而原生桌面客户端，由于要适配 Windows、macOS 甚至 Linux 等多个操作系统，或是为了适配老旧的系统 API（比如 Windows 7 及之前的 WinForm），很多界面、元素与使用体验可能都要做出很大的牺牲。这样子不仅会产生使用体验上的割裂感，由于有着不同的 UI 元素与字体渲染引擎方案，不同系统下的客户端甚至用户界面都长得大相径庭。 Chrome App 版本的全功能 Notion 笔记 不妨试试下面这两种方法，直接使用我们常用应用的网页端服务，将其当作我们的「桌面应用」，这样： 不仅可以省去下载安装桌面客户端的繁琐步骤 还能够享受最新 Web 技术搭建的现代化 UI 对于 Windows，第一种方案可以解决 基于 Chromium 的应用（比如用 Electron 技术构建的 Notion、Slack 等客户端）糟糕的字体渲染引擎所带来的 衬线体中文界面 对于 Linux，第二种方案可以解决 尚未支持 Linux 系统的应用（比如未支持 Linux 系统的 Notion 笔记）「桌面客户端」的安装 Chrome App第一种完全不折腾的解决方案就是：直接使用 Chrome 浏览器来给我们的网页生成一个「桌面应用」。 首先，用 Chrome 浏览器打开想要转换为「桌面客户端」的网页（我以少数派的 Slack 群为例子，地址为：https://sspai-club.slack.com/messages），将登录后正常使用状态的网页 URL 收藏到书签栏： 收藏至书签栏 然后，打开 Chrome App 页面：chrome://apps，将刚刚收藏的标签页项目拖拽到下面的空白处，在应用图标上右键，勾选「在窗口中打开」，然后点击创建快捷方式，在弹出的菜单栏处选择勾选「桌面」或「开始菜单」： 将网页添加至 Chrome App 页面，并制作快捷方式 这样一个单窗口的桌面应用快捷方式就出现在我们的开始菜单或桌面了： Slack Chrome App 的快捷方式 不过，我们会发现这个快捷方式的名称和图标都有问题，我们「右键 &gt; 更多 &gt; 打开文件位置」，就来到了 Chrome 应用快捷方式的文件夹。在这里，我们可以直接修改其文件名，并通过「右键 &gt; 属性 &gt; 更改图标」来配置其图标： 修改 Chrome App 的名称、图标 需要注意的是，针对 Windows 系统，其图标仅支持 ico 格式的文件，我们可以通过 ConvertICO 方便的将 png 图片转化为 ico 文件，从而自定义图标。 这样配置之后，一个近乎完美的「桌面应用」就可以直接使用了。我经过一段时间的使用，跟来自微软商店的 Slack 版本进行对比： 功能上，据我的体验来说，没有任何功能上面的缺失 UI 界面上，是高度一致的，并且 Chrome App 版本的字体渲染是正常的非衬线体 — 微软雅黑 Slack Chrome App 和 Slack Desktop for Windows UI 字体对比 令人愉悦。😄 Nativefier Make any web page a desktop application. 另一种解决办法就是利用开源的 Nativefier 将网页转制成为一个 可安装的 桌面应用，支持 macOS 10.9+ / Windows / Linux 系统。其原理就是将网页利用 Electron 技术将网页内容封装起来，成为一个可执行、可安装的应用程序。 示例图来自 Nativefier 项目首页 然而这样的方式需要一些比较复杂的安装配置。由于 Nativefier 是 Node.js 编写的，所以不仅需要安装 Node.js 环境，还要安装 npm 包管理器，才可以通过 npm install nativefier -g 安装 Nativefier。安装之后 Nativefier 也只有命令行的交互方式，没有图形化界面。幸而有高手帮我们简化了这一流程：Web2Desk。 Your Favorite 🌎 websites to 🖥 desktop apps in 1️⃣ one click 🚀 Web2Desk 的构建过程 Web2Desk 让我们可以直接输入网页链接、应用名称和应用图标，然后经过其在服务器上面的构建，直接给我们提供 Windows、macOS 和 Linux 的原生安装程序的下载。 经过我自己的测试，我在本地、自己的电脑上面利用 Nativefier 构建安装一个桌面应用需要很长很长时间（由于国内的网络环境，下载一些依赖特别慢。），而利用 Web2Desk 服务，不到两分钟全平台的桌面程序就全部加载完成了，十分便捷。我自己在 Linux 下的 Notion 云笔记桌面客户端就是利用 Web2Desk 服务构建的。 Notion Desktop on Manjaro Linux 使用体验说实话，我这样推崇将网页端直接用作桌面应用程序的使用方法，主要就是为了 解决 Windows 上面 Chromium 应用糟糕的中文字体渲染。比如 Notion 和 Slack，他们两个的 Windows 桌面客户端都将中文直接渲染成了宋体，在应用的 UI 中使用衬线体太影响使用体验了。 针对 Notion 和 Slack 两个应用来说，我自己使用下来自己确实没有任何的功能缺失，当然一方面是 Slack 本身就需要联网才可以使用，另一方面是我自己处于「不联网」的状态太少了。 微博、少数派和即刻的「桌面客户端」 与此同时，除了解决字体渲染的问题，那些只提供手机端 App 的应用（比如我派和即刻）、或是桌面版本的应用支持得很垃圾的应用（比如微博提供的那令人绝望的 UWP 版本客户端），我们都可以利用这样方便的办法来给我们自己做一个「客户端」。 网页端的程序越来越丰富，功能上越来越全面，我们直接使用它们的体验也越来越好。与此同时，我们省去了下载巨大安装包的繁琐步骤，开发者省去了适配全平台的繁重任务，这确实是应用程序未来的方向。Web first! 💪]]></content>
      <tags>
        <tag>桌面App</tag>
        <tag>网页应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Flutter 开发一个完整的应用是怎样的体验？]]></title>
    <url>%2F2019%2F06%2F27%2F%E7%94%A8-Flutter-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E5%BA%94%E7%94%A8%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[Flutter 是自 Ruby on Rails 或 Go 以来最让我感到兴奋的技术。 经过多年的努力深入学习 iOS 应用开发，最终疏远了那么多 Android 好友，这让我感到害怕。 此外，当时的跨平台框架对我来说毫无吸引力。 就在两年前，meetup(译注：社交应用) 展示了用跨平台移动框架编写的应用程序，我觉得这些框架太苛刻，不稳定，不友好的开发体验，难以使用，过于复杂，即便在一两年后也不会使用。 所以我刚刚完成了第一个 Flutter 应用程序，我觉得可以放心的将更多的时间投入到 Flutter 框架中。 编写 Flutter 应用程序一直是一个试金石，并且 Flutter 证明了自己。 Flutter 完全能够胜任跨 iOS 和 Android 平台的开发。 我也喜欢写后端，我的妻子 Irina 是一个 UX，这样的组合很强悍。 这将是一个很长的博客文章，因为有很多要涵盖： 我将 iOS 应用程序移植到 Flutter 的经验 关于 Flutter 的思考 对 Google 团队的建议 我打算快速过滤一下我的想法，以便可以开始开始编写教程（以及更多应用程序！）。 1. 将 iOS 应用程序移植到 Flutter自从我上个月关于 Flutter 的文章以来，我觉得下一步是要真正深入了解一下 Flutter 了。我非常喜欢拥有详尽例子的教程（例如 Digital Ocean 或 Auth0 的教程）。端到端，详细，高质量的例子让我对新技术感兴趣，因为我能够真正看到近乎生产的现成代码并且是以正确的方式来实现。所以我想做同样的 Flutter 教程。 因此，有了这些目标，重新编写已经在 App Store 上架的 iOS 应用是很好的选择。 Steady Calendar（主页，产品搜索），是我妻子 Irina 和我几年前在柏林生活时设计和开发的习惯追踪器。从那时起，它就成了一个产品，让我们迷上了设计，实施和发布产品的满足感，该产品通过采用健康的习惯帮助他人改善生活。 我基本上花了一两个月的时间将这个 iOS 应用移植到 Flutter，这样我的 Flutter 教程才更有说服力。 未来一段时间我会出一系列教程来讲解 app 中已经实现的内容： 一个“登录前”的导航页。 Facebook / 电子邮件注册并登录。 显示日历的网格视图，用户可以点按以突出显示他们完成目标的日期。 跨平台表单。 使用Scoped 模型进行 Redux 风格的状态管理 具有栈结构，定位元素，图像和按钮的自定义 UI。 ListView。 简单的多语言国际化 UI。 跨平台的导航栏。 全球样式的小部件。 集成测试。 将应用程序提交到 Apple App Store。 将应用提交到 Google Play 商店。 2. 关于 Flutter 的思考虽然我已经写了超过 17 年的后端和网络应用程序，其中 4 年大量参与 iOS 开发，而在去年的工作中，甚至需要大量使用 React Native。 下面是学习 Flutter 明显的优势： 开发人员的经验，来自社区的强有力的支持。 因为对 Flutter 的热情，从 Stack Overflow，Google Groups 到博客文章的所有内容都是高质量的。 Google 工程师竭尽所能，积极参与回答 Google Group 上的问题，这让 Google Group 成为一个很棒的社区。 在与来自不同背景的工程师合作时，他们非常有耐心和专业，这对很多其他公司来说很难说了。 这里还有一个活跃的社区，成员们非常活跃，并提供非常周到的答案。 文档很详尽。 这些库非常稳定，并且 Flutter 是基于 Dart，这种语言已经存在多年，学习非常简单，因为它更加成熟并且经过了时间的考验。 总之，Flutter 能给你提供很棒的开发体验。 正如预期的那样，使用 Dart 编写的第三方库的可用性较低。然而，至少在我的经验中，这些都无关紧要。我需要使用的 95％的功能都是可用的，只有一个例外，即一些集成了流行分析工具的三方库，但没有一个简单的 HTTP 包装器可以处理。 Material Design 小部件是 Flutter 框架的重要组成部分，非常适合用于专业的跨平台应用程序，用于与 iOS 用户区分开来。我不能向我的 iOS 用户呈现 Material Design 小部件，因为这会让我的应用看起来与他们不同。 Flutter 确实提供了自己的一套 iOS 小部件，但这些小部件还不够全面。幸运的是，在我写的 Steady 应用程序中，大多数用户界面是自定义的。但对于表单类的小部件来说，这很有挑战性。总的来说，Flutter 的文档，示例和 overallFlutter SDK 主要是围绕 Material Design 进行的，这很好，但是对于像我这样的 iOS 开发人员来说需要更多的平衡。 在 Flutter 中开发自定义 UI 非常简单。在有过 CocoaTouch / iOS 开发背景后，我对 UI 有很高的标准。在深入了解 Flutter 代码和自己编写自定义 UI 的经验后，Google 团队确实做到了自定义 UI 的简化。当然，有一些小部件我认为有些矫枉过正，会使得学习曲线更复杂（即中心小部件），但这无关紧要。在编写了一个真正的应用程序之后，我很快就会开始看到他们可能会定期使用的最关键小部件的模式（将在未来的教程中介绍）。 作为 iOS 用户，花几个月时间重新编写我的原生 iOS 应用程序 Steady Calendar，并且第一次在 Android 设备上运行起来真的很让人兴奋。我想这与其他跨移动平台框架总是让我退却有关。如果你花费几个月的业余时间，开发一些东西，并意识到你可以在两个主要平台上运行它，那么你会感到很震惊。尽管对于大多数人来说这无关痛痒，但无论如何我需要分享它！ 编写跨平台应用程序会给你带来更多设计方面的挑战，但这与 Flutter 本身没有任何关系，而是与多平台开发有关。 当你计划一个 Flutter 应用程序时，请确保有一个好的设计师和一个很好的自定义 UI 模拟库或已经准备好了 Flutter 应用的开发，以便你有条不紊的使用 Material Design 或 Cupertino 小部件。 在前一种情况下，这不是一个 Flutter 问题，而是编写跨平台应用程序的挑战，你需要确保 UI 设计是基于使用约定的 Android 用户和 iOS 用户。 学习使用 Dart 是件很快乐的事。 我喜欢使用类似 TypeScript 或 Flow 的稳定性和可靠性。 为了把它放到上下文中，我有一点 React 背景，并且在过去的几个月里一直在为我的日常工作努力学习 React Native。 我已经用 Objective-C 和 Swift 工作了很多年。 Dart 是一股清流，因为它不会过于复杂，并且拥有强大的核心库和包。 老实说，我认为即使是高中新生也可以使用 Dart 进行基本编程。 我经常听到关于又要学习新语言的抱怨，但对于 Dart 来说，仅需要一两个小时，最多一天就能掌握。 Flutter 足够震撼。 尽管 Flutter 还不完美，但在我看来，学习曲线，易用性，可用工具使其成为比我过去使用的任何其他移动框架更好的平台。 Google 应该做什么 Google 团队的朋友们应继续在其 Google 网上论坛中提供周到，友好且反应迅速的支持。 这是一个很大的优点，更好的支持，更易上手也是框架脱颖而出的原因。 支持和培养社区分为的团队很容易讨人喜欢，并且拥有良好，积极的态度，这至关重要。 从社区成员那里获取调查，看看哪些小部件可能根本没用。 对于不那么有用的小部件，只需从文档教程中删除它们或完全弃用它们。 例如，’Center’小部件适用于 Hello 程序，World 容器，除此之外，我不知道还有什么其他用处。 为什么“容器”这种更普遍的东西不具备做同样事情的属性？ 这是一个非常简单的例子，但我认为这是 Go 之所以如此成功的部分原因，因为它的核心库是十分精简的。 投入更多精力在 iOS 用户上。针对 Android 用户， Material Design 非常适合进行快速迭代。 但我绝不会在 iOS 应用中使用 Material Design。尽管如此，至今需要了解大量三方库功能才能进行 iOS 开发，让我觉得学习 Flutter 仍然比 swift 更友好，更简单。 如果 Flutter 能有更多 iOS 风格的小部件，我想很多 iOS 用户都会喜欢学习 Flutter。 推出更多功能特性的视频。 我希望看到更多这样的教程：https：//flutter.io/get-started/codelab/，还有展示与后端集成的“端到端”教程。 主题应用应该少关注 Material Design。 同样，如果我正在编写 iOS 应用程序，我不想使用’MaterialApp’小部件。 主题似乎与此紧密相关，它应该更通用。 降低 Firebase 在文档中的出现频率，减少 Firebase 的相关推送。 我意识到 Firebase 对于快速上手非常有用，有助于新手更容易上手，但是很多人的后端已经开发完成，或者不会考虑使用 Firebase。 所以我认为更多地强调如何使用简单的 Web 服务和 JSON 会有所帮助。为此 我不得不阅读很多关于此的第三方教程，因为我认为文档不够现实。 未来我可能会出一篇更详细的文章来进行说明。 到目前为止，我对 Flutter 整体感到非常满意。 接下来，我将考虑重新编写另一款已上架的 iOS 应用，www.brewswap.co该应用更复杂（Tinder 风格的照片滑动，实时聊天等）。 到目前为止，这些是我能想到的主要内容。 像任何框架一样，有很多不足和学习曲线问题，但总的来说，Flutter 是我觉得我真的可以投资的东西，最重要的是，非常喜欢使用。]]></content>
      <tags>
        <tag>flutter</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora使用不完全总结]]></title>
    <url>%2F2019%2F06%2F27%2FTypora%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一个typora使用方法的不完全总结：]]></content>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过DaoCloud的持续集成发布Hexo博客]]></title>
    <url>%2F2019%2F06%2F27%2F%E9%80%9A%E8%BF%87DaoCloud%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%8F%91%E5%B8%83Hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[什么是持续集成 持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。 每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。 在Hexo博客中，运用持续集成可以让你在每一台设备上都能够更新博客，拜托本地hexo的束缚。 需要用到的：http://Coding.net（http://Coding.net之于Github的好处在于他有手机客户端，满足你在手机上写博客的想法。; Daocloud; git; hexo; node.js 环境搭建安装git访问 git 下载并且安装适合你的操作系统的版本 安装node.js访问 node.js 下载并且安装适合你的操作系统的版本 安装hexohexo 连接http://Coding.net在http://Coding.net上新建一个私有项目，以下我们称之为博客源项目，将你在本地安装的hexo推送到该项目的master分支。 为什么必须使用私有项目，因为稍后我们需要在这个项目内上传私钥。 配置DaoCloud创建项目 新建项目时，在设置代码源处选择http://Coding.net，并且选择你所创建的博客源项目，开启持续集成，执行环境选择国外，发布应用镜像选择镜像仓库。 配置 配置持续构建流程在hexo博客文件夹的根目录下新建一个名为daocloud.yml的文件，文件名全部小写，写入以下内容： 1234567891011121314151617181920212223242526272829version: &quot;2.0&quot;test: image: daocloud.io/starkchen/blog_ci:latest #填写镜像地址 install: - npm install before_script: - mkdir ~/.ssh - mv .daocloud/id_rsa ~/.ssh/id_rsa - mv .daocloud/ssh_config ~/.ssh/config - chmod 600 ~/.ssh/id_rsa - chmod 600 ~/.ssh/config - eval $(ssh-agent) - ssh-add ~/.ssh/id_rsa - rm -rf .daocloud # 配置git全局的用户名和邮件地址 - git config --global user.name &quot;your-username&quot; - git config --global user.email &quot;your-email-address&quot; script: - hexo clean - hexo g - hexo d # 删除私钥文件夹 - rm -rf ~/.ssh/build: image: dockerfile_path: Dockerfile build_dir: / cache: true 镜像地址：DaoCloud控制台&gt;镜像仓库&gt;镜像 找到 配置git仓库 在.gitignore文件中插入以下字段 12345.DS_StoreThumbs.db*.logpublic/.deploy*/ 配置容器在根目录下新建Dockerfile文件，注意此文件名称需要区分大小写。 123456789101112131415161718FROM node:slimMAINTAINER your_name &lt;your_email&gt;# instal basic tool RUN apt-get update &amp;&amp; apt-get install -y git ssh-client ca-certificates --no-install-recommends &amp;&amp; rm -r /var/lib/apt/lists/*# set time zoneRUN echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone &amp;&amp; dpkg-reconfigure -f noninteractive tzdataRUN npm install# install hexoRUN npm install hexo-cli -g# install hexo serverRUN npm install hexo-server# set base dir#RUN mkdir /hexo# set home dir#WORKDIR /hexoEXPOSE 4000#CMD [&quot;/bin/bash&quot;] 注意自行修改your_name和your_email字符串 配置密匙在根目录下新建 .daocloud 目录，拷贝你的 id_rsa 进入 新建一个名为 ssh_config 的文件，写入以下内容 12StrictHostKeyChecking noUserKnownHostsFile /dev/null 将所有更改提交到git仓库 完成接下来的行为将由DaoCloud自动完成，不久后你就能看到博客已经部署好了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[最完美的Hexo多电脑同步方法]]></title>
    <url>%2F2019%2F06%2F27%2F%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Hexo%E5%A4%9A%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[经常我们有一个场景：需要在公司或者家庭多个电脑完成Hexo的博客撰写和发布工作。这就涉及到Hexo多电脑的同步问题。 网上的方案基本上都是多分支方案。也即，在同一个仓库创建两个分支： Hexo分支 – 用来保存所有Hexo的源文件 master分支 – 用来保存Hexo生成的博客文件 在创建GitHub Pages或者Coding Pages时，以master分支为pages分支。Hexo的deploy指向master分支部署pages，git的管理指向Hexo分支。 但是这里有一个巨大的问题，就是多分支的方案一定是让完整的Hexo源文件暴露在公开的仓库了。这对一些Hexo博客采用的leancloud阅读次数管理、多说评论等服务的私有secret key也暴露在公开仓库分支了。如果对这些配置的_config.yml进行单独管理的话，又不能在另一台电脑直接git pull同步，非常的麻烦。 所以Hexo最完美的多电脑同步方法是，创建两个仓库： Hexo私有仓库 – 用来保存所有Hexo的源文件 master公开仓库 – 用来保存Hexo生成的博客文件 下面来具体讲讲实现方法。 基础假设这里假设读者已经建立起了Hexo的博客系统了，实现了比方说： 利用hexo d 直接deploy Hexo博客 实现了Hexo的GitHub和Coding国外和国内的同时发布 自行定义了例如next的第三方主题 Let’go!创建私有仓库注册一个Coding账号，然后创建一个私有项目，名称为Hexo-my 建立本地git仓库进入你现有的Hexo文件夹，删除第三方主题的git配置，如对next主题 1rm -fr ./themes/next/.git/ 然后建立本地的git仓库 1git init 创建一个.gitignore文件，并放在Hexo的根目录，内容为： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ push到私有仓库1234git remote add origin https://git.coding.net/&lt;yourname&gt;/Hexo-my.gitgit add .git commit -m "my first private hexo"git push -u origin master 至此，就完成了本地Hexo源码的全备份 在另一台电脑进行Hexo写作上面已经完成了Hexo的全备份，那么如果在另一台电脑进行Hexo编辑呢。当然首先你也要完成node/npm/hexo/git等环境的搭建和配置。 Hexo拉取1git clone https://git.coding.net/&lt;yourname&gt;/Hexo-my.git 这样你就拥有了你的所有Hexo源文件 Hexo编写和发布尽管拉取下来了，还需要建立一下Hexo的环境，这里需要格外注意的一点是：千万不要用hexo init命令。原因是当前目录已经建立了git仓库环境, hexo init会覆盖到当前的git环境，重建一个新的，这样和我们的私有Hexo源码仓库脱离了联系。 正确的做法是： 1npm install 因为package.json里面已经保存了hexo的必备资源包信息，npm install后Hexo环境就建立起来了。 接下来就进行正常的编写和发布就好。本地预览的命令还是： 12hexo ghexo s Hexo的发布命令是hexo d。 最后执行git status把更改的新文件git add和git commit，最后git push到私有仓库，又会完成Hexo源码仓库的同步。 Hexo仓库更新下次进行Hexo仓库拉取时执行： 12git fetch --all #将git上所有文件拉取到本地git reset --hard origin/master #强制将本地内容指向刚刚同步git云端内容 reset 对所拉取的文件不做任何处理，此处不用 pull 是因为本地尚有许多文件，使用 pull 会有一些版本冲突，解决起来也麻烦，而本地的文件都是初始化生成的文件，较拉取的库里面的文件而言基本无用，所以直接丢弃。 END从此，世界是如此的美好。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo史上最全搭建教程]]></title>
    <url>%2F2019%2F06%2F24%2Fhexo%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。 准备工作 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行npm install -g hexo（要翻墙） 本地搭建hexo静态博客 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙） 生成完模板，运行npm install（目前貌似不用运行这一步） 最后运行：hexo server （运行程序，访问本地localhost:4000可以看到博客已经搭建成功） 将博客与Github关联 在Github上创建名字为XXX.github.io的项目，XXX为自己的github用户名。 打开本地的MyBlog文件夹项目内的_config.yml配置文件，将其中的type设置为git 1234deploy: type: git repository: https://github.com/tengzhangchao/tengzhangchao.github.io.git branch: master 运行：npm install hexo-deployer-git –save 运行：hexo g（本地生成静态文件） 运行：hexo d（将本地静态文件推送至Github） 此时，打开浏览器，访问http://tengzhangchao.github.io 绑定域名 博客已经搭建好，也能通过github的域名访问，但总归还是用自己的域名比较舒服。因为我们需要设置将自己的域名绑定到github这个博客项目上。 域名提供商设置 添加2条A记录： @—&gt;192.30.252.154 @—&gt;192.30.252.153 添加一条CNAME记录： CNAME—&gt;tengzhangchao.github.io 博客添加CNAME文件 配置完域名解析后，进入博客目录，在source目录下新建CNAME文件，写入域名，如：thief.one 运行：hexo g 运行：hexo d 更新博客内容 至此博客已经搭建完毕，域名也已经正常解析，那么剩下的问题就是更新内容了。 更新文章 在MyBlog目录下执行：hexo new “我的第一篇文章”，会在source-&gt;_posts文件夹内生成一个.md文件。 编辑该文件（遵循Markdown规则） 修改起始字段 title 文章的标题 date 创建日期 （文件的创建日期 ） updated 修改日期 （ 文件的修改日期） comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字（文件名） 编写正文内容（MakeDown） hexo clean 删除本地静态文件（Public目录），可不执行。 hexo g 生成本地静态文件（Public目录） hexo deploy 将本地静态文件推送至github（hexo d） 添加菜单进入theme目录，编辑_config_yml文件，找到menu:字段，在该字段下添加一个字段。 1234menu: home: / about: /about ...... 然后找到lanhuages目录，编辑zh-Hans.yml文件： 1234menu: home: 首页 about: 关于作者 ...... 更新页面显示的中文字符，最后进入theme目录下的Source目录，新增一个about目录，里面写一个index.html文件。 文章内插入图片在文章中写入: 1![](/upload_image/1.jpg) 然后进入themes-主题名-source-upload_image目录下(自己创建)，将图片放到这个目录下，就可以了。 说明：当执行hexo g命令时，会自动把图片复制到 public文件的upload_image目录下。 个性化设置基本信息 在根目录下的_config.yml文件中，可以修改标题，作者等信息。打开编辑该文件，注意：每一个值的冒号后面都有一个半角空格！ 未生效的写法：title:nMask的博客 能生效的写法：title:[空格]nMask的博客 主题访问主题列表，获取主题代码。 进入themes目录，进入以下操作： 下载主题 (以next主题为例) 1git clone https://github.com/iissnan/hexo-theme-next.git（主题的地址） 打开__config.yml文件，将themes修改为next（下载到的主题文件夹的名字） hexo g hexo d 关于hexo-next主题下的一些个性化配置，参考：Next主题配置 主题美化文章中添加居中模块文章Markdown中填写如下： 1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 在文章底部增加版权信息在目录 next/layout/_macro/下添加 my-copyright.swig： 1234567891011121314151617181920212223242526272829303132&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import "my-post-copyright" 如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: date: tags: categories: copyright: true--- 自定义hexo new生成md文件的选项在/scaffolds/post.md文件中添加： 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright: truepermalink: 01top: 0password:--- 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。 123456789101112&lt;!--&lt;div class="powered-by"&gt; &#123;&#123; __('footer.powered', '&lt;a class="theme-link" rel="external nofollow" href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125;&lt;/div&gt;&lt;div class="theme-info"&gt; &#123;&#123; __('footer.theme') &#125;&#125; - &lt;a class="theme-link" rel="external nofollow" href="https://github.com/iissnan/hexo-theme-next"&gt; NexT.&#123;&#123; theme.scheme &#125;&#125; &lt;/a&gt;&lt;/div&gt;--&gt; 文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在meta标签后面插入这样一段代码： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后文章中添加： 1password: nmask 如果password后面为空，则表示不用密码。 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如: 12345---......copyright: truetop: 100--- 默认不设置则为0，数值相同时按时间排序。 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: 12&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 添加热度next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig在”leancloud-visitors-count”&gt;标签后面添加℃。然后打开，/themes/next/languages/zh-Hans.yml，将visitors内容改为热度即可。 主页文章添加阴影效果打开\themes\next\source\css_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 鼠标点击小红心的设置将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 背景的设置将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面，标签之前 添加以下代码： 12&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式： 12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 博文压缩在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在博客根目录下新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 搜索功能安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 增加阅读排行统计页面首先我们可以使用leancloud来统计页面阅读数量，以及储存这些信息，然后通过leancloud提供的api编写js脚本来获取阅读数量信息，并展示在页面上。首先新建一个page页面，hexo new page “”,然后编辑此.md文件，写下： 1234567891011121314151617181920212223242526&lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize("", "");&lt;/script&gt; //需要写上leancloud的key&lt;script type="text/javascript"&gt; var time=0 var title="" var url="" var query = new AV.Query('Counter');//表名 query.notEqualTo('id',0); //id不为0的结果 query.descending('time'); //结果按阅读次数降序排序 query.limit(20); //最终只返回10条结果 query.find().then(function (todo) &#123; for (var i=0;i&lt;10;i++)&#123; var result=todo[i].attributes; time=result.time; //阅读次数 title=result.title; //文章标题 url=result.url; //文章url var content="&lt;p&gt;"+"&lt;font color='#0477ab'&gt;"+"【阅读次数:"+time+"】"+"&lt;a href='"+"http://thief.one"+url+"'&gt;"+title+"&lt;/font&gt;"+"&lt;/a&gt;"+"&lt;/p&gt;"; // document.write("&lt;a href='"+"http://thief.one/"+url+"'&gt;"+title+"&lt;/a&gt;"+" Readtimes:"+time+"&lt;br&gt;"); document.getElementById("heheda").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error"); &#125;);&lt;/script&gt; 最终的效果查看：http://thief.one/count 多说替换成来必力评论更新于@2017年5月18日多说已经宣布下线了，因此我找了个来必力评论系统来替换，以下是替换的教程，教程内容来自：https://blog.smoker.cc/web/add-comments-livere-for-hexo-theme-next.html 来必力评价优点：界面美观缺点：不支持数据导入，加载慢 首先在 _config.yml 文件中添加如下配置： 1livere_uid: your uid 其中 livere_uid 即注册来必力获取到的 uid。在 layout/_scripts/third-party/comments/ 目录中添加 livere.swig，文件内容如下： 1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 优先使用其他评论插件，如果其他评论插件没有开启，且LiveRe评论插件配置开启了，则使用LiveRe。其中脚本代码为上一步管理页面中获取到的。在layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include './comments/livere.swig' %&#125; 引入 LiveRe 评论插件。最后，在 layout/_partials/comments.swig 文件中条件最后追加LiveRe插件是否引用的判断逻辑： 123&#123;% elseif theme.livere_uid %&#125; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt;&#123;% endif %&#125; 最后打开博客瞧瞧吧！ 多说替换成网易云跟贴最好的方法就是更新next主题，因为最新版本的主题已经支持这几种评论。如果不想更新主题，则往下看： 网易云跟贴评价：性能稳定，功能中规中矩，支持数据导入 首先在 _config.yml 文件中添加如下配置： 1gentie_productKey: #your-gentie-product-key 其中 gentie_productKey 即注册网易云跟贴获取到的key。在 layout/_scripts/third-party/comments/ 目录中添加 gentie.swig，文件内容如下： 12345678910111213141516&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125; &#123;% if theme.gentie_productKey %&#125; &#123;% set gentie_productKey = theme.gentie_productKey %&#125; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: "", productKey: "&#123;&#123;gentie_productKey&#125;&#125;", target: "cloud-tie-wrapper" &#125;; &lt;/script&gt; &lt;script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 在layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include './comments/gentie.swig' %&#125; 最后，在 layout/_partials/comments.swig 文件中条件最后追加网易云跟帖插件引用的判断逻辑： 123&#123;% elseif theme.gentie_productKey %&#125; &lt;div id="cloud-tie-wrapper" class="cloud-tie-wrapper"&gt; &lt;/div&gt; 报错解决（一）Deployer not found: git当编辑__config.yml文件，将type: git设置完成后，运行hexo g 报错：git not found解决方案：可以在MyBlog目录下运行: npm install hexo-deployer-git –save。 （二）permission denied当执行: hexo deploy 报错时，把__config.yml中的github连接形式从ssh改成http。 （三）当在themes目录下载主题时，报错。将该目录只读属性取消。 （四）genrnate 报错检查_config.yml配置中，键值对冒号后面是否已经预留了一个半角空格。 （五）ERROR Plugin load failed: hexo-generator-feed12npm install hexo-generator-feednpm install hexo-generator-feed --save （六）fatal: The remote end hung up unexpectedly123$ git config https.postBuffer 524288000$ git config http.postBuffer 524288000$ git config ssh.postBuffer 524288000 （七）hero d推送的内容有问题 首先检查下.deploy_git文件夹下的.git文件是否存在，此.git文件指定了hexo d时推送public文件夹，而不是所有的内容。如果此.git文件不存在，则会出现推送内容错误。 用npm install hexo-deployer-git –save生成的.deploy_git不包含.git文件，因此正确的做法是.deploy_git文件夹也需要备份，然后再用npm install hexo-deployer-git –save更新一下其内容即可。 如果已经出现这个错误，则删除.deploy_git，重新hexo d。 （八）hexo s报错在新版本的mac上，安装运行hexo会报此错误，但不影响使用。 1&#123; Error: Cannot find module 解决方案： 1npm install hexo --no-optional Local Search错误 最近发现Local Search搜索出来的连接有错误，到不是说连接不对，而是当我在/aaa/目录下搜索一个页面时，跳转到了/aaa/正确的连接/，这样明显是正确的，应该是跟目录+跳转的目录。 网上搜索了下，没有类似的案例，那么自己动手修改吧，打开node_modules/hexo-generator-searchdb/templates下的xml.ejs文件： 1&lt;url&gt;&lt;%- ("../../../../../../../../"+post.path) %&gt;&lt;/url&gt; 说明：将这个文件的两处url都改成这样就可以了。 异地同步博客内容 现在电脑已经很普及了，因为一般来说我们都是公司一台电脑，家里一台电脑，那么如何将两台电脑上博客的内容同步内，即两台电脑上都可以编辑更新博客？要解决这个问题，首先我们要清楚我们博客文件的组成： node_modules public scaffolds source themes _config_yml db.json package.json .deploy_git 以上为利用hexo生成的博客全部内容，那么当我们执行hexo d时，正真被推送到github上的又有哪些内容呢？ 我们可以看下github上的tengzhangchao.github.io项目，发现里面只有Public目录下的内容。也就是说，我们博客上呈现的内容，其实就是public下的文件内容。那么这个Pulic目录是怎么生成的呢？ 一开始hexo init的时候是没有public目录的，而当我们运行hexo g命令时，public目录被生成了，换句话说hexo g命令就是用来生成博客文件的（会根据_config.yml，source目录文件以及themes目录下文件生成）。同样当我们运行hexo clean命令时，public目录被删除了。 好了，既然我们知道了决定博客显示内容的只有一个Public目录，而public目录又是可以动态生成的，那么其实我们只要在不同电脑上同步可以生成Public目录的文件即可。 以下文件以及目录是必须要同步的： source themes _config.yml db.json package.json .deploy_git 同步的方式有很多种，可以每次更新后都备份到一个地址。我采用github去备份，也就是新建一个项目用来存放以上文件，每次更新后推送到github上，用作备份同步。 同步完必须的文件后，怎么再其他电脑上也可以更新博客呢？ 前提假设我们现在配置了一台新电脑，里面没有安装任何有关博客的东西，那么我们开始吧： 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行npm install -g hexo（要翻墙） 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙) 我们重复了一开始搭建博客的步骤，重新生成了一个新的模板，这个模板中包含了hexo生成的一些文件。 git clone 我们备份的项目，生成一个文件夹，如：MyBlogData 将MyBlog里面的node_modules、scaffolds文件夹复制到MyBlogData里面。 做完这些，从表面上看，两台电脑上MyBlogData目录下的文件应该都是一样的了。那么我们运行hexo ghexo d试试，如果会报错，则往下看。 这是因为.deploy_git没有同步，在MyBlogData目录内运行:npm install hexo-deployer-git –save后再次推送即可 总结流程：当我们每次更新MyBlog内容后，先利用hexo将public推送到github，然后再将其余必须同步的文件利用git推送到github。 SEO优化seo优化对于网站是否能被搜索引擎快速收录有很大帮助，因此适当做一些seo还是有必要的，以下内容参考：https://lancelot_lewis.coding.me/2016/08/16/blog/Hexo-NexT-SEO/ 添加sitemap文件安装以下2个插件，然后重启hexo后，网站根目录（source）下会生成sitemap.xml与baidusitemap.xml文件，搜索引擎在爬取时会参照文件中的url去收录。 1234npm install hexo-generator-sitemap --save-devhexo d -gnpm install hexo-generator-baidu-sitemap --save-devhexo d -g 添加robots.txt新建robots.txt文件，添加以下文件内容，把robots.txt放在hexo站点的source文件下。 1234567891011User-agent: * Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://thief.one/sitemap.xmlSitemap: http://thief.one/baidusitemap.xml 首页title的优化更改index.swig文件，文件路径是your-hexo-site\themes\next\layout，将下面代码 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock 观察首页title就是标题+描述了。 MakeDown语法123456789101112131415161718[hexo](http://www.baidu.com) 表示超链接##大标题###小标题&lt;!-- more --&gt;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125;blah blah blah&#123;% endcq %&#125;空格 中文全角空格表示---文章标题---&gt;内容 区块引用*1*2*3列表*内容* 表示强调内容![Alt text](/path/to/img.jpg) 图片![](/upload_image/20161012/1.png) 详细Markdown语法请参考：MakeDown语法 参考文章http://www.jianshu.com/p/f054333ac9e6https://neveryu.github.io/2016/09/30/hexo-next-two/ 提醒：在更新博客内容时，最好先在本地调试完毕后（hexo server），再推送到github上。]]></content>
      <categories>
        <category>系统搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>

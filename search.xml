<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo史上最全搭建教程]]></title>
    <url>%2F2020%2F08%2F13%2F2020%E7%9A%84%E7%AC%94%E8%AE%B0%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。 在信息越来越丰富的今天，有一批敢于尝鲜的笔记爱好者们已经不再痴迷于以简洁语法为代表的 Markdown，而是转向自由化、定制化的模块化笔记。 他们利用各式各样的模块打造高度可视化的笔记，并公开发表，传播影响力。在看到这些精美的作品后，又有一批用户发现模块化提供了更好的编辑和整理体验，以及可视化带来的效用。 但市面上的享誉盛名的模块化笔记琳琅满目，导致这些后来者不知道选择哪款作为主力笔记，这真是一个幸福的烦恼。所以，我将完整对比现在最流行的、知名度最高的 5 款模块化笔记，帮助你挑选适合自己的笔记 app。 一眼看完强大功能现在最流行的新兴笔记 app 分别是《Notion》《Roam Research》《Wolai》《Craft》 和《Obsidian》。尽管最后一款并不是模块化笔记，但不妨碍它们共同给笔记 app 注入了新的活力。 先对比下最为重要的功能。 大家可以根据这张表格初步了解重要的功能，接下来将介绍下它们各自最强大的功能。 为什么你要选其中一款这 5 款笔记 app 各有千秋，看完之后相信一定有一款能击中你的心。 Notion：最强大的 Database《Notion》是将模块化笔记发扬光大的先驱者。 提到它，先想到的一定是各式各样的模块。比如下图我用了重点、标题、文本、无序列表、内嵌视频 5 种模块，并拖拽将其并列，从而实现强化版的康奈尔笔记。 既可以边看视频边记笔记，也可以通过左边的关键词回顾右边的内容。 但我更想说的是被称为 2.0 版本的灵魂「Database」模块。它的灵感来自于《Airtable》，本质上是一个关系型数据库。有了它，《Notion》才和其他普通笔记软件真正拉开了差距。 由于每一行数据都是一个单独页面，所以它能够帮助我们更好地组织同类型笔记，并且在该页面下记录相关内容，最后根据我们的需要筛选出符合某一场景的内容。比如我就用它来组织所有的稿件。 这只是其中一个用法，配合它其他的功能，你甚至可以自建一个免费的《Things 3》作为你新的 GTD 软件。更多用法可以参照官方模板，或网络搜索。 Roam Research：让你的笔记编织成网不知道你的英语老师教你背单词的方法是不是以一个单词为中心，然后向外扩散写下尽可能多能想到的单词，并且保证它们之间有联系。 比如下图就是我以「Apple」为中心展开的单词联想，写多了之后，你会发现它可能会变成这样。 这其实才是我们大脑记忆的真实样子，知识不是独立的，而是各自有联系。 《Notion》的数据库帮助我们更好的组织和管理笔记，而《Roam Research》引进的双向链接和关系图则帮我们更好地建立起了笔记之间的联系。 此前的笔记链接只能单向跳转，即你过去了回不来，但双向链接可以让你在笔记之间来去自如。这特别像我们在回顾手写笔记时的样子，摊开笔记，一会看下这个知识点，一会看下那个知识点，思考两者有什么联系。双向链接现在就直接把该页面相关的其他页面在最底下给你展示完整，而你只需要负责思考。 对于这种网状结构的笔记，跳来跳去自然是很麻烦的，好在 Roam Research 还提供了侧边栏，只需按住 Shift 再打开即可。侧边栏用于快速查看参考页面，并且可以同时显示多条记录，这对于查看同一页面的多个引用是十分友好的。 此外，《Roam Research》的块引用、页面别名、逻辑词筛选内容等强大功能增强了我们做笔记的能力，更多内容可阅读《秒杀传统型笔记！支持 Markdown 和双向链接的 Roam Research 为什么这么强？》。 Obsidian：大屏幕的福音《Obsidian》则是另外一款同样专注于双向链接和页面关系图的笔记 app。 但它的特别之处是本地编辑和本地存储，把数据安全交到你手里。 最直接的好处就是响应速度极快，不会出现因为网络问题而无法使用的情况。但因本质上是 Markdown 笔记，所以《Obsidian》无法进行段落内容的互相引用，只能是标题互相引用。 另外，它还支持各种插件，你可以根据自己的需要选用插件。所以你还可以做一些其他笔记软件无法做到的事情，比如录音、随机复习笔记、快速新建卡片盒笔记等。 最后，是它另一个特别之处，多窗格展示。 卡片盒笔记的核心是每一个笔记只有一个观点，这样才能帮助你更好地掌握。所以，多窗格非常有效，你能在一个屏幕上看到相关的笔记内容，也就更能有效地理解和记忆。不过前提是你的屏幕足够大。 Wolai：集百家之所长《Wolai》是唯一一款中文化的笔记 app。你可以将其视作《Notion》和《Roam Research》的结合体，它既拥有前者的编辑体验，也具备后者的双向链接和页面关系图。 虽然模块丰富度暂时不及《Notion》，但对中文环境进行了很多功能和设计上的优化，更符合中文用户的使用习惯，比如输入「》」也能实现「&gt;」的效果。除此以外，还对页面关系图进行了优化，内容如下： 可以检索某一页面。 对子页面和引用页面做了设计样式区分。 增加了关系图的展示样式。 增加了 3D 关系图，但目前实用性较差。 这些优化能够更好地帮助我们厘清页面之间的联系，在回顾阶段会有良好的引导作用。 另外一个特别吸引人的小功能是，你可以自定义域名，比如我就自定义了一个 wol.ai/blog。等后期公开分享功能上线后，把自己笔记分享给别人会变得无比简单和迅速。先吃螃蟹的人总会有好处。 目前，《Wolai》仍处于内测阶段，更新速度极快。如果想要抢先体验，可输入 AppSo 专属无限邀请码【9Z4K2K3】。 Craft：丝滑般的体验与上述 4 款软件不同，《Craft》没有那么强大的功能，可以视作《Notion》刚发布时的版本，但胜在苹果生态下的原生体验。同时，它也是唯一一款支持手写功能的笔记 app。 之所以提它，是因为你可能并不需要强大的功能，而只是需要一款在苹果生态下能够快速记录，实时同步，且外观精美的笔记 app。 它同样也是模块化笔记，公开链接的访问速度很快，因此非常适合用来写文章。 你适合哪款笔记 app看完了那么多笔记 app，你是不是觉得每款都很强大，不知道该选择哪款呢？下面是我的个人建议： 如果你是跟学生一样主要用于学习记录的话，考虑到功能和访问速度，建议优选《Obsidian》《Wolai》，其次是《Notion》《Roam Research》。当然，如果你需要丰富的模块的话，《Notion》必然是最优选择。 如果你是开发者，有很多代码需要记录，建议使用《Wolai》《Notion》。 如果你是一个热爱折腾，有很强动手能力的用户，可以尝试《Roam Research》《Obsidian》。它们支持自定义 CSS，你也就可以根据自己的需求，调整页面展示样式。 如果你特别在意数据安全，那就选择《Obsidian》和《Craft》。其余 3 款均为云端笔记软件，且《Notion》《Roam Research》的服务器在境外，但谁又能保证本地存储一定比云端存储安全呢？ 如果你想写出优美的文章，《Notion》《Craft》《Wolai》均可。 其他人可以根据自己的需求和 app 收费情况进行选择。 以上的功能总结和使用推荐是基于当前软件版本。正如苹果和 Android 越来越像，这些软件的功能肯定也会越来越像，毕竟用户都是「你有的，我也要有」，那么选择笔记的落脚点肯定就是细节上的体验了。 哪款能让你坚持记录、长期使用，那么它才是真正能帮助你成长的那款笔记 app。不妨多多尝试，然后选择适合自己的。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>wolai</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[印象笔记+hexo搭建自己的博客]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0%2Bhexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[之前在逛V2EX的时候以外发现一个好玩的东西,就是使用印象笔记Evernote来写文章让后生成响应的html同步到hexo上面。由于自己在生活中使用印象笔记的频率也比较高，而且收藏文章的时候也比较方便。不用自己又特意转成md格式的,这样子省时省力所以决定把自己的博客搭建给换成这个框架来搭建。 搭建过程： 一、安装everblog1. Install everblog: $ npm i everblog -g $ vim ~/.everblogrc token: xxx, noteStoreUrl: xxx, notebook: myblog 2. Clone theme, like everblog-theme-spa: $ git clone https://github.com/everblogjs/everblog-theme-spa myblog $ cd myblog &amp;&amp; npm i 3. Open evernote: create a new notebook named myblog create a new note named \_config.yml, add some configs, like: title, description create some notes 4. Start everblog: $ DEBUG=* everblog start 二、Adapter适配器以上是原框架作者的搭建过程，但是本人自己在实践的过程中出现了很多问题，所以并没有完全按照他的版本来做。我用的是网上搜索出来的另一位作者的方法，他同时也把自己的代码提交到了everblog中，大家可以看commit记录，使用zhougy0717的版本来搭建，这个是我搭建过程中所有遇到的问题他都很热心的帮助解答了，对话记录,希望能帮助到你. 按照以上操作只能算是完成了一半，你还有在你当前的hexo博客目录安装一个everblog-adaptor-hexo（也就是你hexo init的那个目录） $ cd your_hexo_blog_dir $ npm i everblog-adaptor-hexo –save $ vim index.js, add module.exports = require(&#39;everblog-adaptor-hexo&#39;) Open evernote, create \_config.yml(see below) and some notes title: NSWBMW’s blog subtitle: lalala description: my blog author: nswbmw $ everblog build $ hexo server $ open http://localhost:4000/ 注意由于本人在使用以上框架的时候出现了很多问题，我用的Adapter是其他版本的everblog-adaptor-hexo-html cd your_hexo_blog_dir npm i everblog-adaptor-hexo-html –save vim index.js, add: module.exports = require(‘everblog-adaptor-hexo-html’) DEBUG=* everblog build (see everblog) 由于上面安装的第一个步骤也就是npm i everblog -g中安装了很多文件夹，但是有一个evernote这个文件夹的版本不是我所需要的我需要的版本是`evernote@1.25.82,所以你只需要使用命令安装sudo npm install evernote@1.25.82就可以了，当然最好你要先删除掉usr/local/lib/node_modules/evernote先在安装不然我担心它还是会使用默认的evernote2.0`版本。 最后打开你的印象笔记，新建笔记本组新建一个名字.everblogrc文件中notebook同名的笔记本组，我的就叫myblog 我的.everblogrc配置如下 token:d9fab5c755171aedf0d9fab5c755171aedf0d9fab5c755171aedf0d9fab5c755171aedf0 noteStoreUrl: ‘https://app.yinxiang.com/shard/sxx/notestore‘ notebook: myblog serviceHost: app.yinxiang.com sandbox: false 三、申请Token上面的Token是从你自己的个人开发者上面获取到的 国际版Evernote：https://www.evernote.com/api/DeveloperToken.action 国内版印象笔记：https://app.yinxiang.com/api/DeveloperToken.action 由于Evernote因为安全问题已经自动把Token的功能给砍掉了，但是你可以让客服单独为你账号开通 以上所有步骤都完成之后，在你印象笔记里面新建的笔记本组里新建一个名为_config.yml的文件然后把你hexo目录下面的config.yml全部复制进去（后面我印象笔记没有这个东西好像也能同步也不知道是为什么，可能是我换了其他Adapter的原因吧） 只要在首页不是缩略展示文章的都是在印象笔记中完成的，因为.md文件会自动截断文章，但是Evernote的文章内容不会]]></content>
  </entry>
  <entry>
    <title><![CDATA[直接让网页版应用做你的桌面 App]]></title>
    <url>%2F2019%2F06%2F27%2F%E7%9B%B4%E6%8E%A5%E8%AE%A9%E7%BD%91%E9%A1%B5%E7%89%88%E5%BA%94%E7%94%A8%E5%81%9A%E4%BD%A0%E7%9A%84%E6%A1%8C%E9%9D%A2-App%2F</url>
    <content type="text"><![CDATA[💻 随着互联网前端的迅捷发展，越来越多产品网页端的使用体验愈加完善。用 Web 技术搭建的 网页应用 不仅有着现代化的 UI，甚至体验比原生桌面客户端都要好上不少。 而原生桌面客户端，由于要适配 Windows、macOS 甚至 Linux 等多个操作系统，或是为了适配老旧的系统 API（比如 Windows 7 及之前的 WinForm），很多界面、元素与使用体验可能都要做出很大的牺牲。这样子不仅会产生使用体验上的割裂感，由于有着不同的 UI 元素与字体渲染引擎方案，不同系统下的客户端甚至用户界面都长得大相径庭。 Chrome App 版本的全功能 Notion 笔记 不妨试试下面这两种方法，直接使用我们常用应用的网页端服务，将其当作我们的「桌面应用」，这样： 不仅可以省去下载安装桌面客户端的繁琐步骤 还能够享受最新 Web 技术搭建的现代化 UI 对于 Windows，第一种方案可以解决 基于 Chromium 的应用（比如用 Electron 技术构建的 Notion、Slack 等客户端）糟糕的字体渲染引擎所带来的 衬线体中文界面 对于 Linux，第二种方案可以解决 尚未支持 Linux 系统的应用（比如未支持 Linux 系统的 Notion 笔记）「桌面客户端」的安装 Chrome App第一种完全不折腾的解决方案就是：直接使用 Chrome 浏览器来给我们的网页生成一个「桌面应用」。 首先，用 Chrome 浏览器打开想要转换为「桌面客户端」的网页（我以少数派的 Slack 群为例子，地址为：https://sspai-club.slack.com/messages），将登录后正常使用状态的网页 URL 收藏到书签栏： 收藏至书签栏 然后，打开 Chrome App 页面：chrome://apps，将刚刚收藏的标签页项目拖拽到下面的空白处，在应用图标上右键，勾选「在窗口中打开」，然后点击创建快捷方式，在弹出的菜单栏处选择勾选「桌面」或「开始菜单」： 将网页添加至 Chrome App 页面，并制作快捷方式 这样一个单窗口的桌面应用快捷方式就出现在我们的开始菜单或桌面了： Slack Chrome App 的快捷方式 不过，我们会发现这个快捷方式的名称和图标都有问题，我们「右键 &gt; 更多 &gt; 打开文件位置」，就来到了 Chrome 应用快捷方式的文件夹。在这里，我们可以直接修改其文件名，并通过「右键 &gt; 属性 &gt; 更改图标」来配置其图标： 修改 Chrome App 的名称、图标 需要注意的是，针对 Windows 系统，其图标仅支持 ico 格式的文件，我们可以通过 ConvertICO 方便的将 png 图片转化为 ico 文件，从而自定义图标。 这样配置之后，一个近乎完美的「桌面应用」就可以直接使用了。我经过一段时间的使用，跟来自微软商店的 Slack 版本进行对比： 功能上，据我的体验来说，没有任何功能上面的缺失 UI 界面上，是高度一致的，并且 Chrome App 版本的字体渲染是正常的非衬线体 — 微软雅黑 Slack Chrome App 和 Slack Desktop for Windows UI 字体对比 令人愉悦。😄 Nativefier Make any web page a desktop application. 另一种解决办法就是利用开源的 Nativefier 将网页转制成为一个 可安装的 桌面应用，支持 macOS 10.9+ / Windows / Linux 系统。其原理就是将网页利用 Electron 技术将网页内容封装起来，成为一个可执行、可安装的应用程序。 示例图来自 Nativefier 项目首页 然而这样的方式需要一些比较复杂的安装配置。由于 Nativefier 是 Node.js 编写的，所以不仅需要安装 Node.js 环境，还要安装 npm 包管理器，才可以通过 npm install nativefier -g 安装 Nativefier。安装之后 Nativefier 也只有命令行的交互方式，没有图形化界面。幸而有高手帮我们简化了这一流程：Web2Desk。 Your Favorite 🌎 websites to 🖥 desktop apps in 1️⃣ one click 🚀 Web2Desk 的构建过程 Web2Desk 让我们可以直接输入网页链接、应用名称和应用图标，然后经过其在服务器上面的构建，直接给我们提供 Windows、macOS 和 Linux 的原生安装程序的下载。 经过我自己的测试，我在本地、自己的电脑上面利用 Nativefier 构建安装一个桌面应用需要很长很长时间（由于国内的网络环境，下载一些依赖特别慢。），而利用 Web2Desk 服务，不到两分钟全平台的桌面程序就全部加载完成了，十分便捷。我自己在 Linux 下的 Notion 云笔记桌面客户端就是利用 Web2Desk 服务构建的。 Notion Desktop on Manjaro Linux 使用体验说实话，我这样推崇将网页端直接用作桌面应用程序的使用方法，主要就是为了 解决 Windows 上面 Chromium 应用糟糕的中文字体渲染。比如 Notion 和 Slack，他们两个的 Windows 桌面客户端都将中文直接渲染成了宋体，在应用的 UI 中使用衬线体太影响使用体验了。 针对 Notion 和 Slack 两个应用来说，我自己使用下来自己确实没有任何的功能缺失，当然一方面是 Slack 本身就需要联网才可以使用，另一方面是我自己处于「不联网」的状态太少了。 微博、少数派和即刻的「桌面客户端」 与此同时，除了解决字体渲染的问题，那些只提供手机端 App 的应用（比如我派和即刻）、或是桌面版本的应用支持得很垃圾的应用（比如微博提供的那令人绝望的 UWP 版本客户端），我们都可以利用这样方便的办法来给我们自己做一个「客户端」。 网页端的程序越来越丰富，功能上越来越全面，我们直接使用它们的体验也越来越好。与此同时，我们省去了下载巨大安装包的繁琐步骤，开发者省去了适配全平台的繁重任务，这确实是应用程序未来的方向。Web first! 💪]]></content>
      <tags>
        <tag>桌面App</tag>
        <tag>网页应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 Flutter 开发一个完整的应用是怎样的体验？]]></title>
    <url>%2F2019%2F06%2F27%2F%E7%94%A8-Flutter-%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E5%BA%94%E7%94%A8%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[Flutter 是自 Ruby on Rails 或 Go 以来最让我感到兴奋的技术。 经过多年的努力深入学习 iOS 应用开发，最终疏远了那么多 Android 好友，这让我感到害怕。 此外，当时的跨平台框架对我来说毫无吸引力。 就在两年前，meetup(译注：社交应用) 展示了用跨平台移动框架编写的应用程序，我觉得这些框架太苛刻，不稳定，不友好的开发体验，难以使用，过于复杂，即便在一两年后也不会使用。 所以我刚刚完成了第一个 Flutter 应用程序，我觉得可以放心的将更多的时间投入到 Flutter 框架中。 编写 Flutter 应用程序一直是一个试金石，并且 Flutter 证明了自己。 Flutter 完全能够胜任跨 iOS 和 Android 平台的开发。 我也喜欢写后端，我的妻子 Irina 是一个 UX，这样的组合很强悍。 这将是一个很长的博客文章，因为有很多要涵盖： 我将 iOS 应用程序移植到 Flutter 的经验 关于 Flutter 的思考 对 Google 团队的建议 我打算快速过滤一下我的想法，以便可以开始开始编写教程（以及更多应用程序！）。 1. 将 iOS 应用程序移植到 Flutter自从我上个月关于 Flutter 的文章以来，我觉得下一步是要真正深入了解一下 Flutter 了。我非常喜欢拥有详尽例子的教程（例如 Digital Ocean 或 Auth0 的教程）。端到端，详细，高质量的例子让我对新技术感兴趣，因为我能够真正看到近乎生产的现成代码并且是以正确的方式来实现。所以我想做同样的 Flutter 教程。 因此，有了这些目标，重新编写已经在 App Store 上架的 iOS 应用是很好的选择。 Steady Calendar（主页，产品搜索），是我妻子 Irina 和我几年前在柏林生活时设计和开发的习惯追踪器。从那时起，它就成了一个产品，让我们迷上了设计，实施和发布产品的满足感，该产品通过采用健康的习惯帮助他人改善生活。 我基本上花了一两个月的时间将这个 iOS 应用移植到 Flutter，这样我的 Flutter 教程才更有说服力。 未来一段时间我会出一系列教程来讲解 app 中已经实现的内容： 一个“登录前”的导航页。 Facebook / 电子邮件注册并登录。 显示日历的网格视图，用户可以点按以突出显示他们完成目标的日期。 跨平台表单。 使用Scoped 模型进行 Redux 风格的状态管理 具有栈结构，定位元素，图像和按钮的自定义 UI。 ListView。 简单的多语言国际化 UI。 跨平台的导航栏。 全球样式的小部件。 集成测试。 将应用程序提交到 Apple App Store。 将应用提交到 Google Play 商店。 2. 关于 Flutter 的思考虽然我已经写了超过 17 年的后端和网络应用程序，其中 4 年大量参与 iOS 开发，而在去年的工作中，甚至需要大量使用 React Native。 下面是学习 Flutter 明显的优势： 开发人员的经验，来自社区的强有力的支持。 因为对 Flutter 的热情，从 Stack Overflow，Google Groups 到博客文章的所有内容都是高质量的。 Google 工程师竭尽所能，积极参与回答 Google Group 上的问题，这让 Google Group 成为一个很棒的社区。 在与来自不同背景的工程师合作时，他们非常有耐心和专业，这对很多其他公司来说很难说了。 这里还有一个活跃的社区，成员们非常活跃，并提供非常周到的答案。 文档很详尽。 这些库非常稳定，并且 Flutter 是基于 Dart，这种语言已经存在多年，学习非常简单，因为它更加成熟并且经过了时间的考验。 总之，Flutter 能给你提供很棒的开发体验。 正如预期的那样，使用 Dart 编写的第三方库的可用性较低。然而，至少在我的经验中，这些都无关紧要。我需要使用的 95％的功能都是可用的，只有一个例外，即一些集成了流行分析工具的三方库，但没有一个简单的 HTTP 包装器可以处理。 Material Design 小部件是 Flutter 框架的重要组成部分，非常适合用于专业的跨平台应用程序，用于与 iOS 用户区分开来。我不能向我的 iOS 用户呈现 Material Design 小部件，因为这会让我的应用看起来与他们不同。 Flutter 确实提供了自己的一套 iOS 小部件，但这些小部件还不够全面。幸运的是，在我写的 Steady 应用程序中，大多数用户界面是自定义的。但对于表单类的小部件来说，这很有挑战性。总的来说，Flutter 的文档，示例和 overallFlutter SDK 主要是围绕 Material Design 进行的，这很好，但是对于像我这样的 iOS 开发人员来说需要更多的平衡。 在 Flutter 中开发自定义 UI 非常简单。在有过 CocoaTouch / iOS 开发背景后，我对 UI 有很高的标准。在深入了解 Flutter 代码和自己编写自定义 UI 的经验后，Google 团队确实做到了自定义 UI 的简化。当然，有一些小部件我认为有些矫枉过正，会使得学习曲线更复杂（即中心小部件），但这无关紧要。在编写了一个真正的应用程序之后，我很快就会开始看到他们可能会定期使用的最关键小部件的模式（将在未来的教程中介绍）。 作为 iOS 用户，花几个月时间重新编写我的原生 iOS 应用程序 Steady Calendar，并且第一次在 Android 设备上运行起来真的很让人兴奋。我想这与其他跨移动平台框架总是让我退却有关。如果你花费几个月的业余时间，开发一些东西，并意识到你可以在两个主要平台上运行它，那么你会感到很震惊。尽管对于大多数人来说这无关痛痒，但无论如何我需要分享它！ 编写跨平台应用程序会给你带来更多设计方面的挑战，但这与 Flutter 本身没有任何关系，而是与多平台开发有关。 当你计划一个 Flutter 应用程序时，请确保有一个好的设计师和一个很好的自定义 UI 模拟库或已经准备好了 Flutter 应用的开发，以便你有条不紊的使用 Material Design 或 Cupertino 小部件。 在前一种情况下，这不是一个 Flutter 问题，而是编写跨平台应用程序的挑战，你需要确保 UI 设计是基于使用约定的 Android 用户和 iOS 用户。 学习使用 Dart 是件很快乐的事。 我喜欢使用类似 TypeScript 或 Flow 的稳定性和可靠性。 为了把它放到上下文中，我有一点 React 背景，并且在过去的几个月里一直在为我的日常工作努力学习 React Native。 我已经用 Objective-C 和 Swift 工作了很多年。 Dart 是一股清流，因为它不会过于复杂，并且拥有强大的核心库和包。 老实说，我认为即使是高中新生也可以使用 Dart 进行基本编程。 我经常听到关于又要学习新语言的抱怨，但对于 Dart 来说，仅需要一两个小时，最多一天就能掌握。 Flutter 足够震撼。 尽管 Flutter 还不完美，但在我看来，学习曲线，易用性，可用工具使其成为比我过去使用的任何其他移动框架更好的平台。 Google 应该做什么 Google 团队的朋友们应继续在其 Google 网上论坛中提供周到，友好且反应迅速的支持。 这是一个很大的优点，更好的支持，更易上手也是框架脱颖而出的原因。 支持和培养社区分为的团队很容易讨人喜欢，并且拥有良好，积极的态度，这至关重要。 从社区成员那里获取调查，看看哪些小部件可能根本没用。 对于不那么有用的小部件，只需从文档教程中删除它们或完全弃用它们。 例如，’Center’小部件适用于 Hello 程序，World 容器，除此之外，我不知道还有什么其他用处。 为什么“容器”这种更普遍的东西不具备做同样事情的属性？ 这是一个非常简单的例子，但我认为这是 Go 之所以如此成功的部分原因，因为它的核心库是十分精简的。 投入更多精力在 iOS 用户上。针对 Android 用户， Material Design 非常适合进行快速迭代。 但我绝不会在 iOS 应用中使用 Material Design。尽管如此，至今需要了解大量三方库功能才能进行 iOS 开发，让我觉得学习 Flutter 仍然比 swift 更友好，更简单。 如果 Flutter 能有更多 iOS 风格的小部件，我想很多 iOS 用户都会喜欢学习 Flutter。 推出更多功能特性的视频。 我希望看到更多这样的教程：https：//flutter.io/get-started/codelab/，还有展示与后端集成的“端到端”教程。 主题应用应该少关注 Material Design。 同样，如果我正在编写 iOS 应用程序，我不想使用’MaterialApp’小部件。 主题似乎与此紧密相关，它应该更通用。 降低 Firebase 在文档中的出现频率，减少 Firebase 的相关推送。 我意识到 Firebase 对于快速上手非常有用，有助于新手更容易上手，但是很多人的后端已经开发完成，或者不会考虑使用 Firebase。 所以我认为更多地强调如何使用简单的 Web 服务和 JSON 会有所帮助。为此 我不得不阅读很多关于此的第三方教程，因为我认为文档不够现实。 未来我可能会出一篇更详细的文章来进行说明。 到目前为止，我对 Flutter 整体感到非常满意。 接下来，我将考虑重新编写另一款已上架的 iOS 应用，www.brewswap.co该应用更复杂（Tinder 风格的照片滑动，实时聊天等）。 到目前为止，这些是我能想到的主要内容。 像任何框架一样，有很多不足和学习曲线问题，但总的来说，Flutter 是我觉得我真的可以投资的东西，最重要的是，非常喜欢使用。]]></content>
      <tags>
        <tag>flutter</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora使用不完全总结]]></title>
    <url>%2F2019%2F06%2F27%2FTypora%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一个typora使用方法的不完全总结：]]></content>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过DaoCloud的持续集成发布Hexo博客]]></title>
    <url>%2F2019%2F06%2F27%2F%E9%80%9A%E8%BF%87DaoCloud%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%8F%91%E5%B8%83Hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[什么是持续集成 持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。 每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。 在Hexo博客中，运用持续集成可以让你在每一台设备上都能够更新博客，拜托本地hexo的束缚。 需要用到的：http://Coding.net（http://Coding.net之于Github的好处在于他有手机客户端，满足你在手机上写博客的想法。; Daocloud; git; hexo; node.js 环境搭建安装git访问 git 下载并且安装适合你的操作系统的版本 安装node.js访问 node.js 下载并且安装适合你的操作系统的版本 安装hexohexo 连接http://Coding.net在http://Coding.net上新建一个私有项目，以下我们称之为博客源项目，将你在本地安装的hexo推送到该项目的master分支。 为什么必须使用私有项目，因为稍后我们需要在这个项目内上传私钥。 配置DaoCloud创建项目 新建项目时，在设置代码源处选择http://Coding.net，并且选择你所创建的博客源项目，开启持续集成，执行环境选择国外，发布应用镜像选择镜像仓库。 配置 配置持续构建流程在hexo博客文件夹的根目录下新建一个名为daocloud.yml的文件，文件名全部小写，写入以下内容： 1234567891011121314151617181920212223242526272829version: &quot;2.0&quot;test: image: daocloud.io/starkchen/blog_ci:latest #填写镜像地址 install: - npm install before_script: - mkdir ~/.ssh - mv .daocloud/id_rsa ~/.ssh/id_rsa - mv .daocloud/ssh_config ~/.ssh/config - chmod 600 ~/.ssh/id_rsa - chmod 600 ~/.ssh/config - eval $(ssh-agent) - ssh-add ~/.ssh/id_rsa - rm -rf .daocloud # 配置git全局的用户名和邮件地址 - git config --global user.name &quot;your-username&quot; - git config --global user.email &quot;your-email-address&quot; script: - hexo clean - hexo g - hexo d # 删除私钥文件夹 - rm -rf ~/.ssh/build: image: dockerfile_path: Dockerfile build_dir: / cache: true 镜像地址：DaoCloud控制台&gt;镜像仓库&gt;镜像 找到 配置git仓库 在.gitignore文件中插入以下字段 12345.DS_StoreThumbs.db*.logpublic/.deploy*/ 配置容器在根目录下新建Dockerfile文件，注意此文件名称需要区分大小写。 123456789101112131415161718FROM node:slimMAINTAINER your_name &lt;your_email&gt;# instal basic tool RUN apt-get update &amp;&amp; apt-get install -y git ssh-client ca-certificates --no-install-recommends &amp;&amp; rm -r /var/lib/apt/lists/*# set time zoneRUN echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone &amp;&amp; dpkg-reconfigure -f noninteractive tzdataRUN npm install# install hexoRUN npm install hexo-cli -g# install hexo serverRUN npm install hexo-server# set base dir#RUN mkdir /hexo# set home dir#WORKDIR /hexoEXPOSE 4000#CMD [&quot;/bin/bash&quot;] 注意自行修改your_name和your_email字符串 配置密匙在根目录下新建 .daocloud 目录，拷贝你的 id_rsa 进入 新建一个名为 ssh_config 的文件，写入以下内容 12StrictHostKeyChecking noUserKnownHostsFile /dev/null 将所有更改提交到git仓库 完成接下来的行为将由DaoCloud自动完成，不久后你就能看到博客已经部署好了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[最完美的Hexo多电脑同步方法]]></title>
    <url>%2F2019%2F06%2F27%2F%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Hexo%E5%A4%9A%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[经常我们有一个场景：需要在公司或者家庭多个电脑完成Hexo的博客撰写和发布工作。这就涉及到Hexo多电脑的同步问题。 网上的方案基本上都是多分支方案。也即，在同一个仓库创建两个分支： Hexo分支 – 用来保存所有Hexo的源文件 master分支 – 用来保存Hexo生成的博客文件 在创建GitHub Pages或者Coding Pages时，以master分支为pages分支。Hexo的deploy指向master分支部署pages，git的管理指向Hexo分支。 但是这里有一个巨大的问题，就是多分支的方案一定是让完整的Hexo源文件暴露在公开的仓库了。这对一些Hexo博客采用的leancloud阅读次数管理、多说评论等服务的私有secret key也暴露在公开仓库分支了。如果对这些配置的_config.yml进行单独管理的话，又不能在另一台电脑直接git pull同步，非常的麻烦。 所以Hexo最完美的多电脑同步方法是，创建两个仓库： Hexo私有仓库 – 用来保存所有Hexo的源文件 master公开仓库 – 用来保存Hexo生成的博客文件 下面来具体讲讲实现方法。 基础假设这里假设读者已经建立起了Hexo的博客系统了，实现了比方说： 利用hexo d 直接deploy Hexo博客 实现了Hexo的GitHub和Coding国外和国内的同时发布 自行定义了例如next的第三方主题 Let’go!创建私有仓库注册一个Coding账号，然后创建一个私有项目，名称为Hexo-my 建立本地git仓库进入你现有的Hexo文件夹，删除第三方主题的git配置，如对next主题 1rm -fr ./themes/next/.git/ 然后建立本地的git仓库 1git init 创建一个.gitignore文件，并放在Hexo的根目录，内容为： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ push到私有仓库1234git remote add origin https://git.coding.net/&lt;yourname&gt;/Hexo-my.gitgit add .git commit -m "my first private hexo"git push -u origin master 至此，就完成了本地Hexo源码的全备份 在另一台电脑进行Hexo写作上面已经完成了Hexo的全备份，那么如果在另一台电脑进行Hexo编辑呢。当然首先你也要完成node/npm/hexo/git等环境的搭建和配置。 Hexo拉取1git clone https://git.coding.net/&lt;yourname&gt;/Hexo-my.git 这样你就拥有了你的所有Hexo源文件 Hexo编写和发布尽管拉取下来了，还需要建立一下Hexo的环境，这里需要格外注意的一点是：千万不要用hexo init命令。原因是当前目录已经建立了git仓库环境, hexo init会覆盖到当前的git环境，重建一个新的，这样和我们的私有Hexo源码仓库脱离了联系。 正确的做法是： 1npm install 因为package.json里面已经保存了hexo的必备资源包信息，npm install后Hexo环境就建立起来了。 接下来就进行正常的编写和发布就好。本地预览的命令还是： 12hexo ghexo s Hexo的发布命令是hexo d。 最后执行git status把更改的新文件git add和git commit，最后git push到私有仓库，又会完成Hexo源码仓库的同步。 Hexo仓库更新下次进行Hexo仓库拉取时执行： 12git fetch --all #将git上所有文件拉取到本地git reset --hard origin/master #强制将本地内容指向刚刚同步git云端内容 reset 对所拉取的文件不做任何处理，此处不用 pull 是因为本地尚有许多文件，使用 pull 会有一些版本冲突，解决起来也麻烦，而本地的文件都是初始化生成的文件，较拉取的库里面的文件而言基本无用，所以直接丢弃。 END从此，世界是如此的美好。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo史上最全搭建教程]]></title>
    <url>%2F2019%2F06%2F24%2Fhexo%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。 准备工作 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行npm install -g hexo（要翻墙） 本地搭建hexo静态博客 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙） 生成完模板，运行npm install（目前貌似不用运行这一步） 最后运行：hexo server （运行程序，访问本地localhost:4000可以看到博客已经搭建成功） 将博客与Github关联 在Github上创建名字为XXX.github.io的项目，XXX为自己的github用户名。 打开本地的MyBlog文件夹项目内的_config.yml配置文件，将其中的type设置为git 1234deploy: type: git repository: https://github.com/tengzhangchao/tengzhangchao.github.io.git branch: master 运行：npm install hexo-deployer-git –save 运行：hexo g（本地生成静态文件） 运行：hexo d（将本地静态文件推送至Github） 此时，打开浏览器，访问http://tengzhangchao.github.io 绑定域名 博客已经搭建好，也能通过github的域名访问，但总归还是用自己的域名比较舒服。因为我们需要设置将自己的域名绑定到github这个博客项目上。 域名提供商设置 添加2条A记录： @—&gt;192.30.252.154 @—&gt;192.30.252.153 添加一条CNAME记录： CNAME—&gt;tengzhangchao.github.io 博客添加CNAME文件 配置完域名解析后，进入博客目录，在source目录下新建CNAME文件，写入域名，如：thief.one 运行：hexo g 运行：hexo d 更新博客内容 至此博客已经搭建完毕，域名也已经正常解析，那么剩下的问题就是更新内容了。 更新文章 在MyBlog目录下执行：hexo new “我的第一篇文章”，会在source-&gt;_posts文件夹内生成一个.md文件。 编辑该文件（遵循Markdown规则） 修改起始字段 title 文章的标题 date 创建日期 （文件的创建日期 ） updated 修改日期 （ 文件的修改日期） comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字（文件名） 编写正文内容（MakeDown） hexo clean 删除本地静态文件（Public目录），可不执行。 hexo g 生成本地静态文件（Public目录） hexo deploy 将本地静态文件推送至github（hexo d） 添加菜单进入theme目录，编辑_config_yml文件，找到menu:字段，在该字段下添加一个字段。 1234menu: home: / about: /about ...... 然后找到lanhuages目录，编辑zh-Hans.yml文件： 1234menu: home: 首页 about: 关于作者 ...... 更新页面显示的中文字符，最后进入theme目录下的Source目录，新增一个about目录，里面写一个index.html文件。 文章内插入图片在文章中写入: 1![](/upload_image/1.jpg) 然后进入themes-主题名-source-upload_image目录下(自己创建)，将图片放到这个目录下，就可以了。 说明：当执行hexo g命令时，会自动把图片复制到 public文件的upload_image目录下。 个性化设置基本信息 在根目录下的_config.yml文件中，可以修改标题，作者等信息。打开编辑该文件，注意：每一个值的冒号后面都有一个半角空格！ 未生效的写法：title:nMask的博客 能生效的写法：title:[空格]nMask的博客 主题访问主题列表，获取主题代码。 进入themes目录，进入以下操作： 下载主题 (以next主题为例) 1git clone https://github.com/iissnan/hexo-theme-next.git（主题的地址） 打开__config.yml文件，将themes修改为next（下载到的主题文件夹的名字） hexo g hexo d 关于hexo-next主题下的一些个性化配置，参考：Next主题配置 主题美化文章中添加居中模块文章Markdown中填写如下： 1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 在文章底部增加版权信息在目录 next/layout/_macro/下添加 my-copyright.swig： 1234567891011121314151617181920212223242526272829303132&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import "my-post-copyright" 如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: date: tags: categories: copyright: true--- 自定义hexo new生成md文件的选项在/scaffolds/post.md文件中添加： 12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: copyright: truepermalink: 01top: 0password:--- 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。 123456789101112&lt;!--&lt;div class="powered-by"&gt; &#123;&#123; __('footer.powered', '&lt;a class="theme-link" rel="external nofollow" href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125;&lt;/div&gt;&lt;div class="theme-info"&gt; &#123;&#123; __('footer.theme') &#125;&#125; - &lt;a class="theme-link" rel="external nofollow" href="https://github.com/iissnan/hexo-theme-next"&gt; NexT.&#123;&#123; theme.scheme &#125;&#125; &lt;/a&gt;&lt;/div&gt;--&gt; 文章加密访问打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在meta标签后面插入这样一段代码： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后文章中添加： 1password: nmask 如果password后面为空，则表示不用密码。 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如: 12345---......copyright: truetop: 100--- 默认不设置则为0，数值相同时按时间排序。 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: 12&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 添加热度next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig在”leancloud-visitors-count”&gt;标签后面添加℃。然后打开，/themes/next/languages/zh-Hans.yml，将visitors内容改为热度即可。 主页文章添加阴影效果打开\themes\next\source\css_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成 鼠标点击小红心的设置将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 背景的设置将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。找到 \themes\next\layout_layout.swing 文件， 在文件的后面，标签之前 添加以下代码： 12&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式： 12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 博文压缩在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在博客根目录下新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html','minify-css','minify-js']); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 搜索功能安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 增加阅读排行统计页面首先我们可以使用leancloud来统计页面阅读数量，以及储存这些信息，然后通过leancloud提供的api编写js脚本来获取阅读数量信息，并展示在页面上。首先新建一个page页面，hexo new page “”,然后编辑此.md文件，写下： 1234567891011121314151617181920212223242526&lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize("", "");&lt;/script&gt; //需要写上leancloud的key&lt;script type="text/javascript"&gt; var time=0 var title="" var url="" var query = new AV.Query('Counter');//表名 query.notEqualTo('id',0); //id不为0的结果 query.descending('time'); //结果按阅读次数降序排序 query.limit(20); //最终只返回10条结果 query.find().then(function (todo) &#123; for (var i=0;i&lt;10;i++)&#123; var result=todo[i].attributes; time=result.time; //阅读次数 title=result.title; //文章标题 url=result.url; //文章url var content="&lt;p&gt;"+"&lt;font color='#0477ab'&gt;"+"【阅读次数:"+time+"】"+"&lt;a href='"+"http://thief.one"+url+"'&gt;"+title+"&lt;/font&gt;"+"&lt;/a&gt;"+"&lt;/p&gt;"; // document.write("&lt;a href='"+"http://thief.one/"+url+"'&gt;"+title+"&lt;/a&gt;"+" Readtimes:"+time+"&lt;br&gt;"); document.getElementById("heheda").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error"); &#125;);&lt;/script&gt; 最终的效果查看：http://thief.one/count 多说替换成来必力评论更新于@2017年5月18日多说已经宣布下线了，因此我找了个来必力评论系统来替换，以下是替换的教程，教程内容来自：https://blog.smoker.cc/web/add-comments-livere-for-hexo-theme-next.html 来必力评价优点：界面美观缺点：不支持数据导入，加载慢 首先在 _config.yml 文件中添加如下配置： 1livere_uid: your uid 其中 livere_uid 即注册来必力获取到的 uid。在 layout/_scripts/third-party/comments/ 目录中添加 livere.swig，文件内容如下： 1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 优先使用其他评论插件，如果其他评论插件没有开启，且LiveRe评论插件配置开启了，则使用LiveRe。其中脚本代码为上一步管理页面中获取到的。在layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include './comments/livere.swig' %&#125; 引入 LiveRe 评论插件。最后，在 layout/_partials/comments.swig 文件中条件最后追加LiveRe插件是否引用的判断逻辑： 123&#123;% elseif theme.livere_uid %&#125; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt;&#123;% endif %&#125; 最后打开博客瞧瞧吧！ 多说替换成网易云跟贴最好的方法就是更新next主题，因为最新版本的主题已经支持这几种评论。如果不想更新主题，则往下看： 网易云跟贴评价：性能稳定，功能中规中矩，支持数据导入 首先在 _config.yml 文件中添加如下配置： 1gentie_productKey: #your-gentie-product-key 其中 gentie_productKey 即注册网易云跟贴获取到的key。在 layout/_scripts/third-party/comments/ 目录中添加 gentie.swig，文件内容如下： 12345678910111213141516&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125; &#123;% if theme.gentie_productKey %&#125; &#123;% set gentie_productKey = theme.gentie_productKey %&#125; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: "", productKey: "&#123;&#123;gentie_productKey&#125;&#125;", target: "cloud-tie-wrapper" &#125;; &lt;/script&gt; &lt;script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 在layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include './comments/gentie.swig' %&#125; 最后，在 layout/_partials/comments.swig 文件中条件最后追加网易云跟帖插件引用的判断逻辑： 123&#123;% elseif theme.gentie_productKey %&#125; &lt;div id="cloud-tie-wrapper" class="cloud-tie-wrapper"&gt; &lt;/div&gt; 报错解决（一）Deployer not found: git当编辑__config.yml文件，将type: git设置完成后，运行hexo g 报错：git not found解决方案：可以在MyBlog目录下运行: npm install hexo-deployer-git –save。 （二）permission denied当执行: hexo deploy 报错时，把__config.yml中的github连接形式从ssh改成http。 （三）当在themes目录下载主题时，报错。将该目录只读属性取消。 （四）genrnate 报错检查_config.yml配置中，键值对冒号后面是否已经预留了一个半角空格。 （五）ERROR Plugin load failed: hexo-generator-feed12npm install hexo-generator-feednpm install hexo-generator-feed --save （六）fatal: The remote end hung up unexpectedly123$ git config https.postBuffer 524288000$ git config http.postBuffer 524288000$ git config ssh.postBuffer 524288000 （七）hero d推送的内容有问题 首先检查下.deploy_git文件夹下的.git文件是否存在，此.git文件指定了hexo d时推送public文件夹，而不是所有的内容。如果此.git文件不存在，则会出现推送内容错误。 用npm install hexo-deployer-git –save生成的.deploy_git不包含.git文件，因此正确的做法是.deploy_git文件夹也需要备份，然后再用npm install hexo-deployer-git –save更新一下其内容即可。 如果已经出现这个错误，则删除.deploy_git，重新hexo d。 （八）hexo s报错在新版本的mac上，安装运行hexo会报此错误，但不影响使用。 1&#123; Error: Cannot find module 解决方案： 1npm install hexo --no-optional Local Search错误 最近发现Local Search搜索出来的连接有错误，到不是说连接不对，而是当我在/aaa/目录下搜索一个页面时，跳转到了/aaa/正确的连接/，这样明显是正确的，应该是跟目录+跳转的目录。 网上搜索了下，没有类似的案例，那么自己动手修改吧，打开node_modules/hexo-generator-searchdb/templates下的xml.ejs文件： 1&lt;url&gt;&lt;%- ("../../../../../../../../"+post.path) %&gt;&lt;/url&gt; 说明：将这个文件的两处url都改成这样就可以了。 异地同步博客内容 现在电脑已经很普及了，因为一般来说我们都是公司一台电脑，家里一台电脑，那么如何将两台电脑上博客的内容同步内，即两台电脑上都可以编辑更新博客？要解决这个问题，首先我们要清楚我们博客文件的组成： node_modules public scaffolds source themes _config_yml db.json package.json .deploy_git 以上为利用hexo生成的博客全部内容，那么当我们执行hexo d时，正真被推送到github上的又有哪些内容呢？ 我们可以看下github上的tengzhangchao.github.io项目，发现里面只有Public目录下的内容。也就是说，我们博客上呈现的内容，其实就是public下的文件内容。那么这个Pulic目录是怎么生成的呢？ 一开始hexo init的时候是没有public目录的，而当我们运行hexo g命令时，public目录被生成了，换句话说hexo g命令就是用来生成博客文件的（会根据_config.yml，source目录文件以及themes目录下文件生成）。同样当我们运行hexo clean命令时，public目录被删除了。 好了，既然我们知道了决定博客显示内容的只有一个Public目录，而public目录又是可以动态生成的，那么其实我们只要在不同电脑上同步可以生成Public目录的文件即可。 以下文件以及目录是必须要同步的： source themes _config.yml db.json package.json .deploy_git 同步的方式有很多种，可以每次更新后都备份到一个地址。我采用github去备份，也就是新建一个项目用来存放以上文件，每次更新后推送到github上，用作备份同步。 同步完必须的文件后，怎么再其他电脑上也可以更新博客呢？ 前提假设我们现在配置了一台新电脑，里面没有安装任何有关博客的东西，那么我们开始吧： 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行npm install -g hexo（要翻墙） 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙) 我们重复了一开始搭建博客的步骤，重新生成了一个新的模板，这个模板中包含了hexo生成的一些文件。 git clone 我们备份的项目，生成一个文件夹，如：MyBlogData 将MyBlog里面的node_modules、scaffolds文件夹复制到MyBlogData里面。 做完这些，从表面上看，两台电脑上MyBlogData目录下的文件应该都是一样的了。那么我们运行hexo ghexo d试试，如果会报错，则往下看。 这是因为.deploy_git没有同步，在MyBlogData目录内运行:npm install hexo-deployer-git –save后再次推送即可 总结流程：当我们每次更新MyBlog内容后，先利用hexo将public推送到github，然后再将其余必须同步的文件利用git推送到github。 SEO优化seo优化对于网站是否能被搜索引擎快速收录有很大帮助，因此适当做一些seo还是有必要的，以下内容参考：https://lancelot_lewis.coding.me/2016/08/16/blog/Hexo-NexT-SEO/ 添加sitemap文件安装以下2个插件，然后重启hexo后，网站根目录（source）下会生成sitemap.xml与baidusitemap.xml文件，搜索引擎在爬取时会参照文件中的url去收录。 1234npm install hexo-generator-sitemap --save-devhexo d -gnpm install hexo-generator-baidu-sitemap --save-devhexo d -g 添加robots.txt新建robots.txt文件，添加以下文件内容，把robots.txt放在hexo站点的source文件下。 1234567891011User-agent: * Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://thief.one/sitemap.xmlSitemap: http://thief.one/baidusitemap.xml 首页title的优化更改index.swig文件，文件路径是your-hexo-site\themes\next\layout，将下面代码 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock 观察首页title就是标题+描述了。 MakeDown语法123456789101112131415161718[hexo](http://www.baidu.com) 表示超链接##大标题###小标题&lt;!-- more --&gt;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125;blah blah blah&#123;% endcq %&#125;空格 中文全角空格表示---文章标题---&gt;内容 区块引用*1*2*3列表*内容* 表示强调内容![Alt text](/path/to/img.jpg) 图片![](/upload_image/20161012/1.png) 详细Markdown语法请参考：MakeDown语法 参考文章http://www.jianshu.com/p/f054333ac9e6https://neveryu.github.io/2016/09/30/hexo-next-two/ 提醒：在更新博客内容时，最好先在本地调试完毕后（hexo server），再推送到github上。]]></content>
      <categories>
        <category>系统搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
